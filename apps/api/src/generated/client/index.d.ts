
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Municipality
 * 
 */
export type Municipality = $Result.DefaultSelection<Prisma.$MunicipalityPayload>
/**
 * Model Vereda
 * 
 */
export type Vereda = $Result.DefaultSelection<Prisma.$VeredaPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentComment
 * 
 */
export type DocumentComment = $Result.DefaultSelection<Prisma.$DocumentCommentPayload>
/**
 * Model RegionalReport
 * 
 */
export type RegionalReport = $Result.DefaultSelection<Prisma.$RegionalReportPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model ReportDelivery
 * 
 */
export type ReportDelivery = $Result.DefaultSelection<Prisma.$ReportDeliveryPayload>
/**
 * Model NewsReadReceipt
 * 
 */
export type NewsReadReceipt = $Result.DefaultSelection<Prisma.$NewsReadReceiptPayload>
/**
 * Model Visit
 * 
 */
export type Visit = $Result.DefaultSelection<Prisma.$VisitPayload>
/**
 * Model VisitLog
 * 
 */
export type VisitLog = $Result.DefaultSelection<Prisma.$VisitLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  COORDINATOR: 'COORDINATOR',
  GESTOR: 'GESTOR',
  USER: 'USER',
  SUPPORT: 'SUPPORT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const NewsCategory: {
  CLIMATE: 'CLIMATE',
  SECURITY: 'SECURITY',
  PUBLIC_ORDER: 'PUBLIC_ORDER',
  HEALTH: 'HEALTH',
  INFRASTRUCTURE: 'INFRASTRUCTURE',
  OTHER: 'OTHER'
};

export type NewsCategory = (typeof NewsCategory)[keyof typeof NewsCategory]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const ReportType: {
  GENERAL: 'GENERAL',
  REGIONAL: 'REGIONAL',
  ALERT: 'ALERT',
  AUDIT: 'AUDIT'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportFormat: {
  PDF: 'PDF',
  XLSX: 'XLSX',
  DOCX: 'DOCX'
};

export type ReportFormat = (typeof ReportFormat)[keyof typeof ReportFormat]


export const DeliveryChannel: {
  EMAIL: 'EMAIL',
  WHATSAPP: 'WHATSAPP',
  DOWNLOAD: 'DOWNLOAD'
};

export type DeliveryChannel = (typeof DeliveryChannel)[keyof typeof DeliveryChannel]


export const VisitSource: {
  MASSIVE: 'MASSIVE',
  MANUAL: 'MANUAL',
  ENRICHED: 'ENRICHED'
};

export type VisitSource = (typeof VisitSource)[keyof typeof VisitSource]


export const VisitReliability: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type VisitReliability = (typeof VisitReliability)[keyof typeof VisitReliability]


export const VisitStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  VERIFIED: 'VERIFIED',
  CANCELLED: 'CANCELLED'
};

export type VisitStatus = (typeof VisitStatus)[keyof typeof VisitStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type NewsCategory = $Enums.NewsCategory

export const NewsCategory: typeof $Enums.NewsCategory

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportFormat = $Enums.ReportFormat

export const ReportFormat: typeof $Enums.ReportFormat

export type DeliveryChannel = $Enums.DeliveryChannel

export const DeliveryChannel: typeof $Enums.DeliveryChannel

export type VisitSource = $Enums.VisitSource

export const VisitSource: typeof $Enums.VisitSource

export type VisitReliability = $Enums.VisitReliability

export const VisitReliability: typeof $Enums.VisitReliability

export type VisitStatus = $Enums.VisitStatus

export const VisitStatus: typeof $Enums.VisitStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AuditLogs
 * const auditLogs = await prisma.auditLog.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs>;

  /**
   * `prisma.municipality`: Exposes CRUD operations for the **Municipality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipalities
    * const municipalities = await prisma.municipality.findMany()
    * ```
    */
  get municipality(): Prisma.MunicipalityDelegate<ExtArgs>;

  /**
   * `prisma.vereda`: Exposes CRUD operations for the **Vereda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veredas
    * const veredas = await prisma.vereda.findMany()
    * ```
    */
  get vereda(): Prisma.VeredaDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.documentComment`: Exposes CRUD operations for the **DocumentComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentComments
    * const documentComments = await prisma.documentComment.findMany()
    * ```
    */
  get documentComment(): Prisma.DocumentCommentDelegate<ExtArgs>;

  /**
   * `prisma.regionalReport`: Exposes CRUD operations for the **RegionalReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionalReports
    * const regionalReports = await prisma.regionalReport.findMany()
    * ```
    */
  get regionalReport(): Prisma.RegionalReportDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.reportDelivery`: Exposes CRUD operations for the **ReportDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportDeliveries
    * const reportDeliveries = await prisma.reportDelivery.findMany()
    * ```
    */
  get reportDelivery(): Prisma.ReportDeliveryDelegate<ExtArgs>;

  /**
   * `prisma.newsReadReceipt`: Exposes CRUD operations for the **NewsReadReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsReadReceipts
    * const newsReadReceipts = await prisma.newsReadReceipt.findMany()
    * ```
    */
  get newsReadReceipt(): Prisma.NewsReadReceiptDelegate<ExtArgs>;

  /**
   * `prisma.visit`: Exposes CRUD operations for the **Visit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visits
    * const visits = await prisma.visit.findMany()
    * ```
    */
  get visit(): Prisma.VisitDelegate<ExtArgs>;

  /**
   * `prisma.visitLog`: Exposes CRUD operations for the **VisitLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitLogs
    * const visitLogs = await prisma.visitLog.findMany()
    * ```
    */
  get visitLog(): Prisma.VisitLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AuditLog: 'AuditLog',
    Region: 'Region',
    Municipality: 'Municipality',
    Vereda: 'Vereda',
    User: 'User',
    Document: 'Document',
    DocumentComment: 'DocumentComment',
    RegionalReport: 'RegionalReport',
    Alert: 'Alert',
    Report: 'Report',
    ReportDelivery: 'ReportDelivery',
    NewsReadReceipt: 'NewsReadReceipt',
    Visit: 'Visit',
    VisitLog: 'VisitLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "auditLog" | "region" | "municipality" | "vereda" | "user" | "document" | "documentComment" | "regionalReport" | "alert" | "report" | "reportDelivery" | "newsReadReceipt" | "visit" | "visitLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Municipality: {
        payload: Prisma.$MunicipalityPayload<ExtArgs>
        fields: Prisma.MunicipalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findFirst: {
            args: Prisma.MunicipalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findMany: {
            args: Prisma.MunicipalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          create: {
            args: Prisma.MunicipalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          createMany: {
            args: Prisma.MunicipalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MunicipalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          delete: {
            args: Prisma.MunicipalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          update: {
            args: Prisma.MunicipalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          deleteMany: {
            args: Prisma.MunicipalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          aggregate: {
            args: Prisma.MunicipalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipality>
          }
          groupBy: {
            args: Prisma.MunicipalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipalityCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityCountAggregateOutputType> | number
          }
        }
      }
      Vereda: {
        payload: Prisma.$VeredaPayload<ExtArgs>
        fields: Prisma.VeredaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VeredaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VeredaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>
          }
          findFirst: {
            args: Prisma.VeredaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VeredaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>
          }
          findMany: {
            args: Prisma.VeredaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>[]
          }
          create: {
            args: Prisma.VeredaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>
          }
          createMany: {
            args: Prisma.VeredaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VeredaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>[]
          }
          delete: {
            args: Prisma.VeredaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>
          }
          update: {
            args: Prisma.VeredaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>
          }
          deleteMany: {
            args: Prisma.VeredaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VeredaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VeredaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VeredaPayload>
          }
          aggregate: {
            args: Prisma.VeredaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVereda>
          }
          groupBy: {
            args: Prisma.VeredaGroupByArgs<ExtArgs>
            result: $Utils.Optional<VeredaGroupByOutputType>[]
          }
          count: {
            args: Prisma.VeredaCountArgs<ExtArgs>
            result: $Utils.Optional<VeredaCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentComment: {
        payload: Prisma.$DocumentCommentPayload<ExtArgs>
        fields: Prisma.DocumentCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          findFirst: {
            args: Prisma.DocumentCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          findMany: {
            args: Prisma.DocumentCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
          }
          create: {
            args: Prisma.DocumentCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          createMany: {
            args: Prisma.DocumentCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
          }
          delete: {
            args: Prisma.DocumentCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          update: {
            args: Prisma.DocumentCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          aggregate: {
            args: Prisma.DocumentCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentComment>
          }
          groupBy: {
            args: Prisma.DocumentCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCommentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCommentCountAggregateOutputType> | number
          }
        }
      }
      RegionalReport: {
        payload: Prisma.$RegionalReportPayload<ExtArgs>
        fields: Prisma.RegionalReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionalReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionalReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>
          }
          findFirst: {
            args: Prisma.RegionalReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionalReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>
          }
          findMany: {
            args: Prisma.RegionalReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>[]
          }
          create: {
            args: Prisma.RegionalReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>
          }
          createMany: {
            args: Prisma.RegionalReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionalReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>[]
          }
          delete: {
            args: Prisma.RegionalReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>
          }
          update: {
            args: Prisma.RegionalReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>
          }
          deleteMany: {
            args: Prisma.RegionalReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionalReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionalReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionalReportPayload>
          }
          aggregate: {
            args: Prisma.RegionalReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegionalReport>
          }
          groupBy: {
            args: Prisma.RegionalReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionalReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionalReportCountArgs<ExtArgs>
            result: $Utils.Optional<RegionalReportCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      ReportDelivery: {
        payload: Prisma.$ReportDeliveryPayload<ExtArgs>
        fields: Prisma.ReportDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>
          }
          findFirst: {
            args: Prisma.ReportDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>
          }
          findMany: {
            args: Prisma.ReportDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>[]
          }
          create: {
            args: Prisma.ReportDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>
          }
          createMany: {
            args: Prisma.ReportDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>[]
          }
          delete: {
            args: Prisma.ReportDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>
          }
          update: {
            args: Prisma.ReportDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDeliveryPayload>
          }
          aggregate: {
            args: Prisma.ReportDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportDelivery>
          }
          groupBy: {
            args: Prisma.ReportDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<ReportDeliveryCountAggregateOutputType> | number
          }
        }
      }
      NewsReadReceipt: {
        payload: Prisma.$NewsReadReceiptPayload<ExtArgs>
        fields: Prisma.NewsReadReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsReadReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsReadReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>
          }
          findFirst: {
            args: Prisma.NewsReadReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsReadReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>
          }
          findMany: {
            args: Prisma.NewsReadReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>[]
          }
          create: {
            args: Prisma.NewsReadReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>
          }
          createMany: {
            args: Prisma.NewsReadReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsReadReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>[]
          }
          delete: {
            args: Prisma.NewsReadReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>
          }
          update: {
            args: Prisma.NewsReadReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>
          }
          deleteMany: {
            args: Prisma.NewsReadReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsReadReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsReadReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsReadReceiptPayload>
          }
          aggregate: {
            args: Prisma.NewsReadReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsReadReceipt>
          }
          groupBy: {
            args: Prisma.NewsReadReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsReadReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsReadReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<NewsReadReceiptCountAggregateOutputType> | number
          }
        }
      }
      Visit: {
        payload: Prisma.$VisitPayload<ExtArgs>
        fields: Prisma.VisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findFirst: {
            args: Prisma.VisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findMany: {
            args: Prisma.VisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          create: {
            args: Prisma.VisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          createMany: {
            args: Prisma.VisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          delete: {
            args: Prisma.VisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          update: {
            args: Prisma.VisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          deleteMany: {
            args: Prisma.VisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          aggregate: {
            args: Prisma.VisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisit>
          }
          groupBy: {
            args: Prisma.VisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCountAggregateOutputType> | number
          }
        }
      }
      VisitLog: {
        payload: Prisma.$VisitLogPayload<ExtArgs>
        fields: Prisma.VisitLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>
          }
          findFirst: {
            args: Prisma.VisitLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>
          }
          findMany: {
            args: Prisma.VisitLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>[]
          }
          create: {
            args: Prisma.VisitLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>
          }
          createMany: {
            args: Prisma.VisitLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>[]
          }
          delete: {
            args: Prisma.VisitLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>
          }
          update: {
            args: Prisma.VisitLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>
          }
          deleteMany: {
            args: Prisma.VisitLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitLogPayload>
          }
          aggregate: {
            args: Prisma.VisitLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitLog>
          }
          groupBy: {
            args: Prisma.VisitLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitLogCountArgs<ExtArgs>
            result: $Utils.Optional<VisitLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    users: number
    reports: number
    generatedReports: number
    visits: number
    documents: number
    assignedUsers: number
    municipalities: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RegionCountOutputTypeCountUsersArgs
    reports?: boolean | RegionCountOutputTypeCountReportsArgs
    generatedReports?: boolean | RegionCountOutputTypeCountGeneratedReportsArgs
    visits?: boolean | RegionCountOutputTypeCountVisitsArgs
    documents?: boolean | RegionCountOutputTypeCountDocumentsArgs
    assignedUsers?: boolean | RegionCountOutputTypeCountAssignedUsersArgs
    municipalities?: boolean | RegionCountOutputTypeCountMunicipalitiesArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionalReportWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountGeneratedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountAssignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountMunicipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
  }


  /**
   * Count Type MunicipalityCountOutputType
   */

  export type MunicipalityCountOutputType = {
    users: number
    assignedUsers: number
    reports: number
    generatedReports: number
    visits: number
    veredas: number
  }

  export type MunicipalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MunicipalityCountOutputTypeCountUsersArgs
    assignedUsers?: boolean | MunicipalityCountOutputTypeCountAssignedUsersArgs
    reports?: boolean | MunicipalityCountOutputTypeCountReportsArgs
    generatedReports?: boolean | MunicipalityCountOutputTypeCountGeneratedReportsArgs
    visits?: boolean | MunicipalityCountOutputTypeCountVisitsArgs
    veredas?: boolean | MunicipalityCountOutputTypeCountVeredasArgs
  }

  // Custom InputTypes
  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipalityCountOutputType
     */
    select?: MunicipalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountAssignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionalReportWhereInput
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountGeneratedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountVeredasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VeredaWhereInput
  }


  /**
   * Count Type VeredaCountOutputType
   */

  export type VeredaCountOutputType = {
    assignedUsers: number
  }

  export type VeredaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUsers?: boolean | VeredaCountOutputTypeCountAssignedUsersArgs
  }

  // Custom InputTypes
  /**
   * VeredaCountOutputType without action
   */
  export type VeredaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VeredaCountOutputType
     */
    select?: VeredaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VeredaCountOutputType without action
   */
  export type VeredaCountOutputTypeCountAssignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedRegions: number
    assignedMunicipalities: number
    assignedVeredas: number
    documents: number
    comments: number
    news: number
    auditLogs: number
    reports: number
    authorizedReports: number
    readReceipts: number
    assignedVisits: number
    delegatedVisits: number
    visitLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedRegions?: boolean | UserCountOutputTypeCountAssignedRegionsArgs
    assignedMunicipalities?: boolean | UserCountOutputTypeCountAssignedMunicipalitiesArgs
    assignedVeredas?: boolean | UserCountOutputTypeCountAssignedVeredasArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    news?: boolean | UserCountOutputTypeCountNewsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    authorizedReports?: boolean | UserCountOutputTypeCountAuthorizedReportsArgs
    readReceipts?: boolean | UserCountOutputTypeCountReadReceiptsArgs
    assignedVisits?: boolean | UserCountOutputTypeCountAssignedVisitsArgs
    delegatedVisits?: boolean | UserCountOutputTypeCountDelegatedVisitsArgs
    visitLogs?: boolean | UserCountOutputTypeCountVisitLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedMunicipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedVeredasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VeredaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionalReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthorizedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReadReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsReadReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDelegatedVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVisitLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitLogWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    comments: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | DocumentCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
  }


  /**
   * Count Type RegionalReportCountOutputType
   */

  export type RegionalReportCountOutputType = {
    alerts: number
    readReceipts: number
  }

  export type RegionalReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | RegionalReportCountOutputTypeCountAlertsArgs
    readReceipts?: boolean | RegionalReportCountOutputTypeCountReadReceiptsArgs
  }

  // Custom InputTypes
  /**
   * RegionalReportCountOutputType without action
   */
  export type RegionalReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReportCountOutputType
     */
    select?: RegionalReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionalReportCountOutputType without action
   */
  export type RegionalReportCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * RegionalReportCountOutputType without action
   */
  export type RegionalReportCountOutputTypeCountReadReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsReadReceiptWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    deliveries: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | ReportCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDeliveryWhereInput
  }


  /**
   * Count Type VisitCountOutputType
   */

  export type VisitCountOutputType = {
    logs: number
  }

  export type VisitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | VisitCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCountOutputType
     */
    select?: VisitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    ipAddress: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string
    ipAddress: string | null
    metadata: JsonValue | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string
      ipAddress: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: string
    name: string
    code: string
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    users?: boolean | Region$usersArgs<ExtArgs>
    reports?: boolean | Region$reportsArgs<ExtArgs>
    generatedReports?: boolean | Region$generatedReportsArgs<ExtArgs>
    visits?: boolean | Region$visitsArgs<ExtArgs>
    documents?: boolean | Region$documentsArgs<ExtArgs>
    assignedUsers?: boolean | Region$assignedUsersArgs<ExtArgs>
    municipalities?: boolean | Region$municipalitiesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Region$usersArgs<ExtArgs>
    reports?: boolean | Region$reportsArgs<ExtArgs>
    generatedReports?: boolean | Region$generatedReportsArgs<ExtArgs>
    visits?: boolean | Region$visitsArgs<ExtArgs>
    documents?: boolean | Region$documentsArgs<ExtArgs>
    assignedUsers?: boolean | Region$assignedUsersArgs<ExtArgs>
    municipalities?: boolean | Region$municipalitiesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      reports: Prisma.$RegionalReportPayload<ExtArgs>[]
      generatedReports: Prisma.$ReportPayload<ExtArgs>[]
      visits: Prisma.$VisitPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      assignedUsers: Prisma.$UserPayload<ExtArgs>[]
      municipalities: Prisma.$MunicipalityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Region$usersArgs<ExtArgs> = {}>(args?: Subset<T, Region$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Region$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Region$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findMany"> | Null>
    generatedReports<T extends Region$generatedReportsArgs<ExtArgs> = {}>(args?: Subset<T, Region$generatedReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    visits<T extends Region$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Region$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Region$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Region$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    assignedUsers<T extends Region$assignedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Region$assignedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    municipalities<T extends Region$municipalitiesArgs<ExtArgs> = {}>(args?: Subset<T, Region$municipalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'String'>
    readonly name: FieldRef<"Region", 'String'>
    readonly code: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
  }

  /**
   * Region.users
   */
  export type Region$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Region.reports
   */
  export type Region$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    where?: RegionalReportWhereInput
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    cursor?: RegionalReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionalReportScalarFieldEnum | RegionalReportScalarFieldEnum[]
  }

  /**
   * Region.generatedReports
   */
  export type Region$generatedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Region.visits
   */
  export type Region$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Region.documents
   */
  export type Region$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Region.assignedUsers
   */
  export type Region$assignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Region.municipalities
   */
  export type Region$municipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    cursor?: MunicipalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Municipality
   */

  export type AggregateMunicipality = {
    _count: MunicipalityCountAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  export type MunicipalityMinAggregateOutputType = {
    id: string | null
    name: string | null
    regionId: string | null
  }

  export type MunicipalityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    regionId: string | null
  }

  export type MunicipalityCountAggregateOutputType = {
    id: number
    name: number
    regionId: number
    _all: number
  }


  export type MunicipalityMinAggregateInputType = {
    id?: true
    name?: true
    regionId?: true
  }

  export type MunicipalityMaxAggregateInputType = {
    id?: true
    name?: true
    regionId?: true
  }

  export type MunicipalityCountAggregateInputType = {
    id?: true
    name?: true
    regionId?: true
    _all?: true
  }

  export type MunicipalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipality to aggregate.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipalities
    **/
    _count?: true | MunicipalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipalityMaxAggregateInputType
  }

  export type GetMunicipalityAggregateType<T extends MunicipalityAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipality[P]>
      : GetScalarType<T[P], AggregateMunicipality[P]>
  }




  export type MunicipalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithAggregationInput | MunicipalityOrderByWithAggregationInput[]
    by: MunicipalityScalarFieldEnum[] | MunicipalityScalarFieldEnum
    having?: MunicipalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipalityCountAggregateInputType | true
    _min?: MunicipalityMinAggregateInputType
    _max?: MunicipalityMaxAggregateInputType
  }

  export type MunicipalityGroupByOutputType = {
    id: string
    name: string
    regionId: string
    _count: MunicipalityCountAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  type GetMunicipalityGroupByPayload<T extends MunicipalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
        }
      >
    >


  export type MunicipalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    regionId?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    users?: boolean | Municipality$usersArgs<ExtArgs>
    assignedUsers?: boolean | Municipality$assignedUsersArgs<ExtArgs>
    reports?: boolean | Municipality$reportsArgs<ExtArgs>
    generatedReports?: boolean | Municipality$generatedReportsArgs<ExtArgs>
    visits?: boolean | Municipality$visitsArgs<ExtArgs>
    veredas?: boolean | Municipality$veredasArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    regionId?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectScalar = {
    id?: boolean
    name?: boolean
    regionId?: boolean
  }

  export type MunicipalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    users?: boolean | Municipality$usersArgs<ExtArgs>
    assignedUsers?: boolean | Municipality$assignedUsersArgs<ExtArgs>
    reports?: boolean | Municipality$reportsArgs<ExtArgs>
    generatedReports?: boolean | Municipality$generatedReportsArgs<ExtArgs>
    visits?: boolean | Municipality$visitsArgs<ExtArgs>
    veredas?: boolean | Municipality$veredasArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MunicipalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }

  export type $MunicipalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipality"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      assignedUsers: Prisma.$UserPayload<ExtArgs>[]
      reports: Prisma.$RegionalReportPayload<ExtArgs>[]
      generatedReports: Prisma.$ReportPayload<ExtArgs>[]
      visits: Prisma.$VisitPayload<ExtArgs>[]
      veredas: Prisma.$VeredaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      regionId: string
    }, ExtArgs["result"]["municipality"]>
    composites: {}
  }

  type MunicipalityGetPayload<S extends boolean | null | undefined | MunicipalityDefaultArgs> = $Result.GetResult<Prisma.$MunicipalityPayload, S>

  type MunicipalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipalityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipalityCountAggregateInputType | true
    }

  export interface MunicipalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipality'], meta: { name: 'Municipality' } }
    /**
     * Find zero or one Municipality that matches the filter.
     * @param {MunicipalityFindUniqueArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipalityFindUniqueArgs>(args: SelectSubset<T, MunicipalityFindUniqueArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipalityFindUniqueOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipalityFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipalityFindFirstArgs>(args?: SelectSubset<T, MunicipalityFindFirstArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipalityFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipalities
     * const municipalities = await prisma.municipality.findMany()
     * 
     * // Get first 10 Municipalities
     * const municipalities = await prisma.municipality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const municipalityWithIdOnly = await prisma.municipality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MunicipalityFindManyArgs>(args?: SelectSubset<T, MunicipalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipality.
     * @param {MunicipalityCreateArgs} args - Arguments to create a Municipality.
     * @example
     * // Create one Municipality
     * const Municipality = await prisma.municipality.create({
     *   data: {
     *     // ... data to create a Municipality
     *   }
     * })
     * 
     */
    create<T extends MunicipalityCreateArgs>(args: SelectSubset<T, MunicipalityCreateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipalities.
     * @param {MunicipalityCreateManyArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipalityCreateManyArgs>(args?: SelectSubset<T, MunicipalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Municipalities and returns the data saved in the database.
     * @param {MunicipalityCreateManyAndReturnArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MunicipalityCreateManyAndReturnArgs>(args?: SelectSubset<T, MunicipalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Municipality.
     * @param {MunicipalityDeleteArgs} args - Arguments to delete one Municipality.
     * @example
     * // Delete one Municipality
     * const Municipality = await prisma.municipality.delete({
     *   where: {
     *     // ... filter to delete one Municipality
     *   }
     * })
     * 
     */
    delete<T extends MunicipalityDeleteArgs>(args: SelectSubset<T, MunicipalityDeleteArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipality.
     * @param {MunicipalityUpdateArgs} args - Arguments to update one Municipality.
     * @example
     * // Update one Municipality
     * const municipality = await prisma.municipality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipalityUpdateArgs>(args: SelectSubset<T, MunicipalityUpdateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipalities.
     * @param {MunicipalityDeleteManyArgs} args - Arguments to filter Municipalities to delete.
     * @example
     * // Delete a few Municipalities
     * const { count } = await prisma.municipality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipalityDeleteManyArgs>(args?: SelectSubset<T, MunicipalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipalityUpdateManyArgs>(args: SelectSubset<T, MunicipalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipality.
     * @param {MunicipalityUpsertArgs} args - Arguments to update or create a Municipality.
     * @example
     * // Update or create a Municipality
     * const municipality = await prisma.municipality.upsert({
     *   create: {
     *     // ... data to create a Municipality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipality we want to update
     *   }
     * })
     */
    upsert<T extends MunicipalityUpsertArgs>(args: SelectSubset<T, MunicipalityUpsertArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityCountArgs} args - Arguments to filter Municipalities to count.
     * @example
     * // Count the number of Municipalities
     * const count = await prisma.municipality.count({
     *   where: {
     *     // ... the filter for the Municipalities we want to count
     *   }
     * })
    **/
    count<T extends MunicipalityCountArgs>(
      args?: Subset<T, MunicipalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipalityAggregateArgs>(args: Subset<T, MunicipalityAggregateArgs>): Prisma.PrismaPromise<GetMunicipalityAggregateType<T>>

    /**
     * Group by Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipalityGroupByArgs['orderBy'] }
        : { orderBy?: MunicipalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipality model
   */
  readonly fields: MunicipalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends Municipality$usersArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    assignedUsers<T extends Municipality$assignedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$assignedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Municipality$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findMany"> | Null>
    generatedReports<T extends Municipality$generatedReportsArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$generatedReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    visits<T extends Municipality$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    veredas<T extends Municipality$veredasArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$veredasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipality model
   */ 
  interface MunicipalityFieldRefs {
    readonly id: FieldRef<"Municipality", 'String'>
    readonly name: FieldRef<"Municipality", 'String'>
    readonly regionId: FieldRef<"Municipality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Municipality findUnique
   */
  export type MunicipalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findUniqueOrThrow
   */
  export type MunicipalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findFirst
   */
  export type MunicipalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findFirstOrThrow
   */
  export type MunicipalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findMany
   */
  export type MunicipalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipalities to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality create
   */
  export type MunicipalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipality.
     */
    data: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
  }

  /**
   * Municipality createMany
   */
  export type MunicipalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipality createManyAndReturn
   */
  export type MunicipalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Municipality update
   */
  export type MunicipalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipality.
     */
    data: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
    /**
     * Choose, which Municipality to update.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality updateMany
   */
  export type MunicipalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
  }

  /**
   * Municipality upsert
   */
  export type MunicipalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipality to update in case it exists.
     */
    where: MunicipalityWhereUniqueInput
    /**
     * In case the Municipality found by the `where` argument doesn't exist, create a new Municipality with this data.
     */
    create: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
    /**
     * In case the Municipality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
  }

  /**
   * Municipality delete
   */
  export type MunicipalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter which Municipality to delete.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality deleteMany
   */
  export type MunicipalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipalities to delete
     */
    where?: MunicipalityWhereInput
  }

  /**
   * Municipality.users
   */
  export type Municipality$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Municipality.assignedUsers
   */
  export type Municipality$assignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Municipality.reports
   */
  export type Municipality$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    where?: RegionalReportWhereInput
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    cursor?: RegionalReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionalReportScalarFieldEnum | RegionalReportScalarFieldEnum[]
  }

  /**
   * Municipality.generatedReports
   */
  export type Municipality$generatedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Municipality.visits
   */
  export type Municipality$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Municipality.veredas
   */
  export type Municipality$veredasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    where?: VeredaWhereInput
    orderBy?: VeredaOrderByWithRelationInput | VeredaOrderByWithRelationInput[]
    cursor?: VeredaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VeredaScalarFieldEnum | VeredaScalarFieldEnum[]
  }

  /**
   * Municipality without action
   */
  export type MunicipalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
  }


  /**
   * Model Vereda
   */

  export type AggregateVereda = {
    _count: VeredaCountAggregateOutputType | null
    _min: VeredaMinAggregateOutputType | null
    _max: VeredaMaxAggregateOutputType | null
  }

  export type VeredaMinAggregateOutputType = {
    id: string | null
    name: string | null
    municipalityId: string | null
  }

  export type VeredaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    municipalityId: string | null
  }

  export type VeredaCountAggregateOutputType = {
    id: number
    name: number
    municipalityId: number
    _all: number
  }


  export type VeredaMinAggregateInputType = {
    id?: true
    name?: true
    municipalityId?: true
  }

  export type VeredaMaxAggregateInputType = {
    id?: true
    name?: true
    municipalityId?: true
  }

  export type VeredaCountAggregateInputType = {
    id?: true
    name?: true
    municipalityId?: true
    _all?: true
  }

  export type VeredaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vereda to aggregate.
     */
    where?: VeredaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veredas to fetch.
     */
    orderBy?: VeredaOrderByWithRelationInput | VeredaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VeredaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veredas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veredas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Veredas
    **/
    _count?: true | VeredaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeredaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeredaMaxAggregateInputType
  }

  export type GetVeredaAggregateType<T extends VeredaAggregateArgs> = {
        [P in keyof T & keyof AggregateVereda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVereda[P]>
      : GetScalarType<T[P], AggregateVereda[P]>
  }




  export type VeredaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VeredaWhereInput
    orderBy?: VeredaOrderByWithAggregationInput | VeredaOrderByWithAggregationInput[]
    by: VeredaScalarFieldEnum[] | VeredaScalarFieldEnum
    having?: VeredaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeredaCountAggregateInputType | true
    _min?: VeredaMinAggregateInputType
    _max?: VeredaMaxAggregateInputType
  }

  export type VeredaGroupByOutputType = {
    id: string
    name: string
    municipalityId: string
    _count: VeredaCountAggregateOutputType | null
    _min: VeredaMinAggregateOutputType | null
    _max: VeredaMaxAggregateOutputType | null
  }

  type GetVeredaGroupByPayload<T extends VeredaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VeredaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeredaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeredaGroupByOutputType[P]>
            : GetScalarType<T[P], VeredaGroupByOutputType[P]>
        }
      >
    >


  export type VeredaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    municipalityId?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
    assignedUsers?: boolean | Vereda$assignedUsersArgs<ExtArgs>
    _count?: boolean | VeredaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vereda"]>

  export type VeredaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    municipalityId?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vereda"]>

  export type VeredaSelectScalar = {
    id?: boolean
    name?: boolean
    municipalityId?: boolean
  }

  export type VeredaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
    assignedUsers?: boolean | Vereda$assignedUsersArgs<ExtArgs>
    _count?: boolean | VeredaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VeredaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }

  export type $VeredaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vereda"
    objects: {
      municipality: Prisma.$MunicipalityPayload<ExtArgs>
      assignedUsers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      municipalityId: string
    }, ExtArgs["result"]["vereda"]>
    composites: {}
  }

  type VeredaGetPayload<S extends boolean | null | undefined | VeredaDefaultArgs> = $Result.GetResult<Prisma.$VeredaPayload, S>

  type VeredaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VeredaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VeredaCountAggregateInputType | true
    }

  export interface VeredaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vereda'], meta: { name: 'Vereda' } }
    /**
     * Find zero or one Vereda that matches the filter.
     * @param {VeredaFindUniqueArgs} args - Arguments to find a Vereda
     * @example
     * // Get one Vereda
     * const vereda = await prisma.vereda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VeredaFindUniqueArgs>(args: SelectSubset<T, VeredaFindUniqueArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vereda that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VeredaFindUniqueOrThrowArgs} args - Arguments to find a Vereda
     * @example
     * // Get one Vereda
     * const vereda = await prisma.vereda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VeredaFindUniqueOrThrowArgs>(args: SelectSubset<T, VeredaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vereda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaFindFirstArgs} args - Arguments to find a Vereda
     * @example
     * // Get one Vereda
     * const vereda = await prisma.vereda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VeredaFindFirstArgs>(args?: SelectSubset<T, VeredaFindFirstArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vereda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaFindFirstOrThrowArgs} args - Arguments to find a Vereda
     * @example
     * // Get one Vereda
     * const vereda = await prisma.vereda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VeredaFindFirstOrThrowArgs>(args?: SelectSubset<T, VeredaFindFirstOrThrowArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Veredas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veredas
     * const veredas = await prisma.vereda.findMany()
     * 
     * // Get first 10 Veredas
     * const veredas = await prisma.vereda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veredaWithIdOnly = await prisma.vereda.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VeredaFindManyArgs>(args?: SelectSubset<T, VeredaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vereda.
     * @param {VeredaCreateArgs} args - Arguments to create a Vereda.
     * @example
     * // Create one Vereda
     * const Vereda = await prisma.vereda.create({
     *   data: {
     *     // ... data to create a Vereda
     *   }
     * })
     * 
     */
    create<T extends VeredaCreateArgs>(args: SelectSubset<T, VeredaCreateArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Veredas.
     * @param {VeredaCreateManyArgs} args - Arguments to create many Veredas.
     * @example
     * // Create many Veredas
     * const vereda = await prisma.vereda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VeredaCreateManyArgs>(args?: SelectSubset<T, VeredaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Veredas and returns the data saved in the database.
     * @param {VeredaCreateManyAndReturnArgs} args - Arguments to create many Veredas.
     * @example
     * // Create many Veredas
     * const vereda = await prisma.vereda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Veredas and only return the `id`
     * const veredaWithIdOnly = await prisma.vereda.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VeredaCreateManyAndReturnArgs>(args?: SelectSubset<T, VeredaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vereda.
     * @param {VeredaDeleteArgs} args - Arguments to delete one Vereda.
     * @example
     * // Delete one Vereda
     * const Vereda = await prisma.vereda.delete({
     *   where: {
     *     // ... filter to delete one Vereda
     *   }
     * })
     * 
     */
    delete<T extends VeredaDeleteArgs>(args: SelectSubset<T, VeredaDeleteArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vereda.
     * @param {VeredaUpdateArgs} args - Arguments to update one Vereda.
     * @example
     * // Update one Vereda
     * const vereda = await prisma.vereda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VeredaUpdateArgs>(args: SelectSubset<T, VeredaUpdateArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Veredas.
     * @param {VeredaDeleteManyArgs} args - Arguments to filter Veredas to delete.
     * @example
     * // Delete a few Veredas
     * const { count } = await prisma.vereda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VeredaDeleteManyArgs>(args?: SelectSubset<T, VeredaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veredas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veredas
     * const vereda = await prisma.vereda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VeredaUpdateManyArgs>(args: SelectSubset<T, VeredaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vereda.
     * @param {VeredaUpsertArgs} args - Arguments to update or create a Vereda.
     * @example
     * // Update or create a Vereda
     * const vereda = await prisma.vereda.upsert({
     *   create: {
     *     // ... data to create a Vereda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vereda we want to update
     *   }
     * })
     */
    upsert<T extends VeredaUpsertArgs>(args: SelectSubset<T, VeredaUpsertArgs<ExtArgs>>): Prisma__VeredaClient<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Veredas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaCountArgs} args - Arguments to filter Veredas to count.
     * @example
     * // Count the number of Veredas
     * const count = await prisma.vereda.count({
     *   where: {
     *     // ... the filter for the Veredas we want to count
     *   }
     * })
    **/
    count<T extends VeredaCountArgs>(
      args?: Subset<T, VeredaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeredaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vereda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeredaAggregateArgs>(args: Subset<T, VeredaAggregateArgs>): Prisma.PrismaPromise<GetVeredaAggregateType<T>>

    /**
     * Group by Vereda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeredaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VeredaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VeredaGroupByArgs['orderBy'] }
        : { orderBy?: VeredaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VeredaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeredaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vereda model
   */
  readonly fields: VeredaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vereda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VeredaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipality<T extends MunicipalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipalityDefaultArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedUsers<T extends Vereda$assignedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Vereda$assignedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vereda model
   */ 
  interface VeredaFieldRefs {
    readonly id: FieldRef<"Vereda", 'String'>
    readonly name: FieldRef<"Vereda", 'String'>
    readonly municipalityId: FieldRef<"Vereda", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vereda findUnique
   */
  export type VeredaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * Filter, which Vereda to fetch.
     */
    where: VeredaWhereUniqueInput
  }

  /**
   * Vereda findUniqueOrThrow
   */
  export type VeredaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * Filter, which Vereda to fetch.
     */
    where: VeredaWhereUniqueInput
  }

  /**
   * Vereda findFirst
   */
  export type VeredaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * Filter, which Vereda to fetch.
     */
    where?: VeredaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veredas to fetch.
     */
    orderBy?: VeredaOrderByWithRelationInput | VeredaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Veredas.
     */
    cursor?: VeredaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veredas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veredas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Veredas.
     */
    distinct?: VeredaScalarFieldEnum | VeredaScalarFieldEnum[]
  }

  /**
   * Vereda findFirstOrThrow
   */
  export type VeredaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * Filter, which Vereda to fetch.
     */
    where?: VeredaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veredas to fetch.
     */
    orderBy?: VeredaOrderByWithRelationInput | VeredaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Veredas.
     */
    cursor?: VeredaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veredas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veredas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Veredas.
     */
    distinct?: VeredaScalarFieldEnum | VeredaScalarFieldEnum[]
  }

  /**
   * Vereda findMany
   */
  export type VeredaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * Filter, which Veredas to fetch.
     */
    where?: VeredaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Veredas to fetch.
     */
    orderBy?: VeredaOrderByWithRelationInput | VeredaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Veredas.
     */
    cursor?: VeredaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Veredas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Veredas.
     */
    skip?: number
    distinct?: VeredaScalarFieldEnum | VeredaScalarFieldEnum[]
  }

  /**
   * Vereda create
   */
  export type VeredaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * The data needed to create a Vereda.
     */
    data: XOR<VeredaCreateInput, VeredaUncheckedCreateInput>
  }

  /**
   * Vereda createMany
   */
  export type VeredaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Veredas.
     */
    data: VeredaCreateManyInput | VeredaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vereda createManyAndReturn
   */
  export type VeredaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Veredas.
     */
    data: VeredaCreateManyInput | VeredaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vereda update
   */
  export type VeredaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * The data needed to update a Vereda.
     */
    data: XOR<VeredaUpdateInput, VeredaUncheckedUpdateInput>
    /**
     * Choose, which Vereda to update.
     */
    where: VeredaWhereUniqueInput
  }

  /**
   * Vereda updateMany
   */
  export type VeredaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Veredas.
     */
    data: XOR<VeredaUpdateManyMutationInput, VeredaUncheckedUpdateManyInput>
    /**
     * Filter which Veredas to update
     */
    where?: VeredaWhereInput
  }

  /**
   * Vereda upsert
   */
  export type VeredaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * The filter to search for the Vereda to update in case it exists.
     */
    where: VeredaWhereUniqueInput
    /**
     * In case the Vereda found by the `where` argument doesn't exist, create a new Vereda with this data.
     */
    create: XOR<VeredaCreateInput, VeredaUncheckedCreateInput>
    /**
     * In case the Vereda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VeredaUpdateInput, VeredaUncheckedUpdateInput>
  }

  /**
   * Vereda delete
   */
  export type VeredaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    /**
     * Filter which Vereda to delete.
     */
    where: VeredaWhereUniqueInput
  }

  /**
   * Vereda deleteMany
   */
  export type VeredaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Veredas to delete
     */
    where?: VeredaWhereInput
  }

  /**
   * Vereda.assignedUsers
   */
  export type Vereda$assignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Vereda without action
   */
  export type VeredaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    dni: string | null
    phone: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    regionId: string | null
    municipalityId: string | null
    createdAt: Date | null
    lastLogin: Date | null
    acceptedTerms: boolean | null
    acceptedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    dni: string | null
    phone: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    regionId: string | null
    municipalityId: string | null
    createdAt: Date | null
    lastLogin: Date | null
    acceptedTerms: boolean | null
    acceptedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    dni: number
    phone: number
    role: number
    isActive: number
    permissions: number
    regionId: number
    municipalityId: number
    createdAt: number
    lastLogin: number
    acceptedTerms: number
    acceptedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    dni?: true
    phone?: true
    role?: true
    isActive?: true
    regionId?: true
    municipalityId?: true
    createdAt?: true
    lastLogin?: true
    acceptedTerms?: true
    acceptedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    dni?: true
    phone?: true
    role?: true
    isActive?: true
    regionId?: true
    municipalityId?: true
    createdAt?: true
    lastLogin?: true
    acceptedTerms?: true
    acceptedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    dni?: true
    phone?: true
    role?: true
    isActive?: true
    permissions?: true
    regionId?: true
    municipalityId?: true
    createdAt?: true
    lastLogin?: true
    acceptedTerms?: true
    acceptedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone: string | null
    role: $Enums.Role
    isActive: boolean
    permissions: JsonValue
    regionId: string | null
    municipalityId: string | null
    createdAt: Date
    lastLogin: Date | null
    acceptedTerms: boolean
    acceptedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    dni?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    regionId?: boolean
    municipalityId?: boolean
    createdAt?: boolean
    lastLogin?: boolean
    acceptedTerms?: boolean
    acceptedAt?: boolean
    region?: boolean | User$regionArgs<ExtArgs>
    municipality?: boolean | User$municipalityArgs<ExtArgs>
    assignedRegions?: boolean | User$assignedRegionsArgs<ExtArgs>
    assignedMunicipalities?: boolean | User$assignedMunicipalitiesArgs<ExtArgs>
    assignedVeredas?: boolean | User$assignedVeredasArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    news?: boolean | User$newsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    authorizedReports?: boolean | User$authorizedReportsArgs<ExtArgs>
    readReceipts?: boolean | User$readReceiptsArgs<ExtArgs>
    assignedVisits?: boolean | User$assignedVisitsArgs<ExtArgs>
    delegatedVisits?: boolean | User$delegatedVisitsArgs<ExtArgs>
    visitLogs?: boolean | User$visitLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    dni?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    regionId?: boolean
    municipalityId?: boolean
    createdAt?: boolean
    lastLogin?: boolean
    acceptedTerms?: boolean
    acceptedAt?: boolean
    region?: boolean | User$regionArgs<ExtArgs>
    municipality?: boolean | User$municipalityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    dni?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    regionId?: boolean
    municipalityId?: boolean
    createdAt?: boolean
    lastLogin?: boolean
    acceptedTerms?: boolean
    acceptedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | User$regionArgs<ExtArgs>
    municipality?: boolean | User$municipalityArgs<ExtArgs>
    assignedRegions?: boolean | User$assignedRegionsArgs<ExtArgs>
    assignedMunicipalities?: boolean | User$assignedMunicipalitiesArgs<ExtArgs>
    assignedVeredas?: boolean | User$assignedVeredasArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    news?: boolean | User$newsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    authorizedReports?: boolean | User$authorizedReportsArgs<ExtArgs>
    readReceipts?: boolean | User$readReceiptsArgs<ExtArgs>
    assignedVisits?: boolean | User$assignedVisitsArgs<ExtArgs>
    delegatedVisits?: boolean | User$delegatedVisitsArgs<ExtArgs>
    visitLogs?: boolean | User$visitLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | User$regionArgs<ExtArgs>
    municipality?: boolean | User$municipalityArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs> | null
      municipality: Prisma.$MunicipalityPayload<ExtArgs> | null
      assignedRegions: Prisma.$RegionPayload<ExtArgs>[]
      assignedMunicipalities: Prisma.$MunicipalityPayload<ExtArgs>[]
      assignedVeredas: Prisma.$VeredaPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      comments: Prisma.$DocumentCommentPayload<ExtArgs>[]
      news: Prisma.$RegionalReportPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      authorizedReports: Prisma.$ReportPayload<ExtArgs>[]
      readReceipts: Prisma.$NewsReadReceiptPayload<ExtArgs>[]
      assignedVisits: Prisma.$VisitPayload<ExtArgs>[]
      delegatedVisits: Prisma.$VisitPayload<ExtArgs>[]
      visitLogs: Prisma.$VisitLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      fullName: string
      dni: string
      phone: string | null
      role: $Enums.Role
      isActive: boolean
      permissions: Prisma.JsonValue
      regionId: string | null
      municipalityId: string | null
      createdAt: Date
      lastLogin: Date | null
      acceptedTerms: boolean
      acceptedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends User$regionArgs<ExtArgs> = {}>(args?: Subset<T, User$regionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    municipality<T extends User$municipalityArgs<ExtArgs> = {}>(args?: Subset<T, User$municipalityArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedRegions<T extends User$assignedRegionsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedRegionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany"> | Null>
    assignedMunicipalities<T extends User$assignedMunicipalitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedMunicipalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany"> | Null>
    assignedVeredas<T extends User$assignedVeredasArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedVeredasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VeredaPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany"> | Null>
    news<T extends User$newsArgs<ExtArgs> = {}>(args?: Subset<T, User$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    authorizedReports<T extends User$authorizedReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$authorizedReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    readReceipts<T extends User$readReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$readReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    assignedVisits<T extends User$assignedVisitsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    delegatedVisits<T extends User$delegatedVisitsArgs<ExtArgs> = {}>(args?: Subset<T, User$delegatedVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    visitLogs<T extends User$visitLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$visitLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly dni: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly permissions: FieldRef<"User", 'Json'>
    readonly regionId: FieldRef<"User", 'String'>
    readonly municipalityId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly acceptedTerms: FieldRef<"User", 'Boolean'>
    readonly acceptedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.region
   */
  export type User$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * User.municipality
   */
  export type User$municipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
  }

  /**
   * User.assignedRegions
   */
  export type User$assignedRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * User.assignedMunicipalities
   */
  export type User$assignedMunicipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    cursor?: MunicipalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * User.assignedVeredas
   */
  export type User$assignedVeredasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vereda
     */
    select?: VeredaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VeredaInclude<ExtArgs> | null
    where?: VeredaWhereInput
    orderBy?: VeredaOrderByWithRelationInput | VeredaOrderByWithRelationInput[]
    cursor?: VeredaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VeredaScalarFieldEnum | VeredaScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    cursor?: DocumentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * User.news
   */
  export type User$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    where?: RegionalReportWhereInput
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    cursor?: RegionalReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionalReportScalarFieldEnum | RegionalReportScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.authorizedReports
   */
  export type User$authorizedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.readReceipts
   */
  export type User$readReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    where?: NewsReadReceiptWhereInput
    orderBy?: NewsReadReceiptOrderByWithRelationInput | NewsReadReceiptOrderByWithRelationInput[]
    cursor?: NewsReadReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsReadReceiptScalarFieldEnum | NewsReadReceiptScalarFieldEnum[]
  }

  /**
   * User.assignedVisits
   */
  export type User$assignedVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * User.delegatedVisits
   */
  export type User$delegatedVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * User.visitLogs
   */
  export type User$visitLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    where?: VisitLogWhereInput
    orderBy?: VisitLogOrderByWithRelationInput | VisitLogOrderByWithRelationInput[]
    cursor?: VisitLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitLogScalarFieldEnum | VisitLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    version: number | null
  }

  export type DocumentSumAggregateOutputType = {
    version: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    url: string | null
    version: number | null
    hash: string | null
    uploaderId: string | null
    regionId: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    url: string | null
    version: number | null
    hash: string | null
    uploaderId: string | null
    regionId: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    url: number
    version: number
    hash: number
    uploaderId: number
    regionId: number
    createdAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    version?: true
  }

  export type DocumentSumAggregateInputType = {
    version?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    url?: true
    version?: true
    hash?: true
    uploaderId?: true
    regionId?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    url?: true
    version?: true
    hash?: true
    uploaderId?: true
    regionId?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    url?: true
    version?: true
    hash?: true
    uploaderId?: true
    regionId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    title: string
    url: string
    version: number
    hash: string | null
    uploaderId: string
    regionId: string | null
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    version?: boolean
    hash?: boolean
    uploaderId?: boolean
    regionId?: boolean
    createdAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | Document$regionArgs<ExtArgs>
    comments?: boolean | Document$commentsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    version?: boolean
    hash?: boolean
    uploaderId?: boolean
    regionId?: boolean
    createdAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | Document$regionArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    url?: boolean
    version?: boolean
    hash?: boolean
    uploaderId?: boolean
    regionId?: boolean
    createdAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | Document$regionArgs<ExtArgs>
    comments?: boolean | Document$commentsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | Document$regionArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
      region: Prisma.$RegionPayload<ExtArgs> | null
      comments: Prisma.$DocumentCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      url: string
      version: number
      hash: string | null
      uploaderId: string
      regionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    region<T extends Document$regionArgs<ExtArgs> = {}>(args?: Subset<T, Document$regionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends Document$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Document$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly version: FieldRef<"Document", 'Int'>
    readonly hash: FieldRef<"Document", 'String'>
    readonly uploaderId: FieldRef<"Document", 'String'>
    readonly regionId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.region
   */
  export type Document$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * Document.comments
   */
  export type Document$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    cursor?: DocumentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentComment
   */

  export type AggregateDocumentComment = {
    _count: DocumentCommentCountAggregateOutputType | null
    _min: DocumentCommentMinAggregateOutputType | null
    _max: DocumentCommentMaxAggregateOutputType | null
  }

  export type DocumentCommentMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type DocumentCommentMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type DocumentCommentCountAggregateOutputType = {
    id: number
    documentId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type DocumentCommentMinAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type DocumentCommentMaxAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type DocumentCommentCountAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentComment to aggregate.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentComments
    **/
    _count?: true | DocumentCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentCommentMaxAggregateInputType
  }

  export type GetDocumentCommentAggregateType<T extends DocumentCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentComment[P]>
      : GetScalarType<T[P], AggregateDocumentComment[P]>
  }




  export type DocumentCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithAggregationInput | DocumentCommentOrderByWithAggregationInput[]
    by: DocumentCommentScalarFieldEnum[] | DocumentCommentScalarFieldEnum
    having?: DocumentCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCommentCountAggregateInputType | true
    _min?: DocumentCommentMinAggregateInputType
    _max?: DocumentCommentMaxAggregateInputType
  }

  export type DocumentCommentGroupByOutputType = {
    id: string
    documentId: string
    userId: string
    content: string
    createdAt: Date
    _count: DocumentCommentCountAggregateOutputType | null
    _min: DocumentCommentMinAggregateOutputType | null
    _max: DocumentCommentMaxAggregateOutputType | null
  }

  type GetDocumentCommentGroupByPayload<T extends DocumentCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentCommentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentCommentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentComment"]>

  export type DocumentCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentComment"]>

  export type DocumentCommentSelectScalar = {
    id?: boolean
    documentId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type DocumentCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentComment"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      userId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["documentComment"]>
    composites: {}
  }

  type DocumentCommentGetPayload<S extends boolean | null | undefined | DocumentCommentDefaultArgs> = $Result.GetResult<Prisma.$DocumentCommentPayload, S>

  type DocumentCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCommentCountAggregateInputType | true
    }

  export interface DocumentCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentComment'], meta: { name: 'DocumentComment' } }
    /**
     * Find zero or one DocumentComment that matches the filter.
     * @param {DocumentCommentFindUniqueArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentCommentFindUniqueArgs>(args: SelectSubset<T, DocumentCommentFindUniqueArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentCommentFindUniqueOrThrowArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentFindFirstArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentCommentFindFirstArgs>(args?: SelectSubset<T, DocumentCommentFindFirstArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentFindFirstOrThrowArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentComments
     * const documentComments = await prisma.documentComment.findMany()
     * 
     * // Get first 10 DocumentComments
     * const documentComments = await prisma.documentComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentCommentWithIdOnly = await prisma.documentComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentCommentFindManyArgs>(args?: SelectSubset<T, DocumentCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentComment.
     * @param {DocumentCommentCreateArgs} args - Arguments to create a DocumentComment.
     * @example
     * // Create one DocumentComment
     * const DocumentComment = await prisma.documentComment.create({
     *   data: {
     *     // ... data to create a DocumentComment
     *   }
     * })
     * 
     */
    create<T extends DocumentCommentCreateArgs>(args: SelectSubset<T, DocumentCommentCreateArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentComments.
     * @param {DocumentCommentCreateManyArgs} args - Arguments to create many DocumentComments.
     * @example
     * // Create many DocumentComments
     * const documentComment = await prisma.documentComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCommentCreateManyArgs>(args?: SelectSubset<T, DocumentCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentComments and returns the data saved in the database.
     * @param {DocumentCommentCreateManyAndReturnArgs} args - Arguments to create many DocumentComments.
     * @example
     * // Create many DocumentComments
     * const documentComment = await prisma.documentComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentComments and only return the `id`
     * const documentCommentWithIdOnly = await prisma.documentComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocumentComment.
     * @param {DocumentCommentDeleteArgs} args - Arguments to delete one DocumentComment.
     * @example
     * // Delete one DocumentComment
     * const DocumentComment = await prisma.documentComment.delete({
     *   where: {
     *     // ... filter to delete one DocumentComment
     *   }
     * })
     * 
     */
    delete<T extends DocumentCommentDeleteArgs>(args: SelectSubset<T, DocumentCommentDeleteArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentComment.
     * @param {DocumentCommentUpdateArgs} args - Arguments to update one DocumentComment.
     * @example
     * // Update one DocumentComment
     * const documentComment = await prisma.documentComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentCommentUpdateArgs>(args: SelectSubset<T, DocumentCommentUpdateArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentComments.
     * @param {DocumentCommentDeleteManyArgs} args - Arguments to filter DocumentComments to delete.
     * @example
     * // Delete a few DocumentComments
     * const { count } = await prisma.documentComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentCommentDeleteManyArgs>(args?: SelectSubset<T, DocumentCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentComments
     * const documentComment = await prisma.documentComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentCommentUpdateManyArgs>(args: SelectSubset<T, DocumentCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentComment.
     * @param {DocumentCommentUpsertArgs} args - Arguments to update or create a DocumentComment.
     * @example
     * // Update or create a DocumentComment
     * const documentComment = await prisma.documentComment.upsert({
     *   create: {
     *     // ... data to create a DocumentComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentComment we want to update
     *   }
     * })
     */
    upsert<T extends DocumentCommentUpsertArgs>(args: SelectSubset<T, DocumentCommentUpsertArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentCountArgs} args - Arguments to filter DocumentComments to count.
     * @example
     * // Count the number of DocumentComments
     * const count = await prisma.documentComment.count({
     *   where: {
     *     // ... the filter for the DocumentComments we want to count
     *   }
     * })
    **/
    count<T extends DocumentCommentCountArgs>(
      args?: Subset<T, DocumentCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentCommentAggregateArgs>(args: Subset<T, DocumentCommentAggregateArgs>): Prisma.PrismaPromise<GetDocumentCommentAggregateType<T>>

    /**
     * Group by DocumentComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentCommentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentComment model
   */
  readonly fields: DocumentCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentComment model
   */ 
  interface DocumentCommentFieldRefs {
    readonly id: FieldRef<"DocumentComment", 'String'>
    readonly documentId: FieldRef<"DocumentComment", 'String'>
    readonly userId: FieldRef<"DocumentComment", 'String'>
    readonly content: FieldRef<"DocumentComment", 'String'>
    readonly createdAt: FieldRef<"DocumentComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentComment findUnique
   */
  export type DocumentCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment findUniqueOrThrow
   */
  export type DocumentCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment findFirst
   */
  export type DocumentCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentComments.
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentComments.
     */
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment findFirstOrThrow
   */
  export type DocumentCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentComments.
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentComments.
     */
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment findMany
   */
  export type DocumentCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentComments.
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment create
   */
  export type DocumentCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentComment.
     */
    data: XOR<DocumentCommentCreateInput, DocumentCommentUncheckedCreateInput>
  }

  /**
   * DocumentComment createMany
   */
  export type DocumentCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentComments.
     */
    data: DocumentCommentCreateManyInput | DocumentCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentComment createManyAndReturn
   */
  export type DocumentCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocumentComments.
     */
    data: DocumentCommentCreateManyInput | DocumentCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentComment update
   */
  export type DocumentCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentComment.
     */
    data: XOR<DocumentCommentUpdateInput, DocumentCommentUncheckedUpdateInput>
    /**
     * Choose, which DocumentComment to update.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment updateMany
   */
  export type DocumentCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentComments.
     */
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentComments to update
     */
    where?: DocumentCommentWhereInput
  }

  /**
   * DocumentComment upsert
   */
  export type DocumentCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentComment to update in case it exists.
     */
    where: DocumentCommentWhereUniqueInput
    /**
     * In case the DocumentComment found by the `where` argument doesn't exist, create a new DocumentComment with this data.
     */
    create: XOR<DocumentCommentCreateInput, DocumentCommentUncheckedCreateInput>
    /**
     * In case the DocumentComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentCommentUpdateInput, DocumentCommentUncheckedUpdateInput>
  }

  /**
   * DocumentComment delete
   */
  export type DocumentCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter which DocumentComment to delete.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment deleteMany
   */
  export type DocumentCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentComments to delete
     */
    where?: DocumentCommentWhereInput
  }

  /**
   * DocumentComment without action
   */
  export type DocumentCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
  }


  /**
   * Model RegionalReport
   */

  export type AggregateRegionalReport = {
    _count: RegionalReportCountAggregateOutputType | null
    _min: RegionalReportMinAggregateOutputType | null
    _max: RegionalReportMaxAggregateOutputType | null
  }

  export type RegionalReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    regionId: string | null
    municipalityId: string | null
    category: $Enums.NewsCategory | null
    priority: $Enums.Priority | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type RegionalReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    regionId: string | null
    municipalityId: string | null
    category: $Enums.NewsCategory | null
    priority: $Enums.Priority | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type RegionalReportCountAggregateOutputType = {
    id: number
    userId: number
    regionId: number
    municipalityId: number
    category: number
    priority: number
    title: number
    content: number
    createdAt: number
    _all: number
  }


  export type RegionalReportMinAggregateInputType = {
    id?: true
    userId?: true
    regionId?: true
    municipalityId?: true
    category?: true
    priority?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type RegionalReportMaxAggregateInputType = {
    id?: true
    userId?: true
    regionId?: true
    municipalityId?: true
    category?: true
    priority?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type RegionalReportCountAggregateInputType = {
    id?: true
    userId?: true
    regionId?: true
    municipalityId?: true
    category?: true
    priority?: true
    title?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type RegionalReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionalReport to aggregate.
     */
    where?: RegionalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionalReports to fetch.
     */
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionalReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionalReports
    **/
    _count?: true | RegionalReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionalReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionalReportMaxAggregateInputType
  }

  export type GetRegionalReportAggregateType<T extends RegionalReportAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionalReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionalReport[P]>
      : GetScalarType<T[P], AggregateRegionalReport[P]>
  }




  export type RegionalReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionalReportWhereInput
    orderBy?: RegionalReportOrderByWithAggregationInput | RegionalReportOrderByWithAggregationInput[]
    by: RegionalReportScalarFieldEnum[] | RegionalReportScalarFieldEnum
    having?: RegionalReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionalReportCountAggregateInputType | true
    _min?: RegionalReportMinAggregateInputType
    _max?: RegionalReportMaxAggregateInputType
  }

  export type RegionalReportGroupByOutputType = {
    id: string
    userId: string
    regionId: string | null
    municipalityId: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt: Date
    _count: RegionalReportCountAggregateOutputType | null
    _min: RegionalReportMinAggregateOutputType | null
    _max: RegionalReportMaxAggregateOutputType | null
  }

  type GetRegionalReportGroupByPayload<T extends RegionalReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionalReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionalReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionalReportGroupByOutputType[P]>
            : GetScalarType<T[P], RegionalReportGroupByOutputType[P]>
        }
      >
    >


  export type RegionalReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    regionId?: boolean
    municipalityId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | RegionalReport$regionArgs<ExtArgs>
    municipality?: boolean | RegionalReport$municipalityArgs<ExtArgs>
    alerts?: boolean | RegionalReport$alertsArgs<ExtArgs>
    readReceipts?: boolean | RegionalReport$readReceiptsArgs<ExtArgs>
    _count?: boolean | RegionalReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionalReport"]>

  export type RegionalReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    regionId?: boolean
    municipalityId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | RegionalReport$regionArgs<ExtArgs>
    municipality?: boolean | RegionalReport$municipalityArgs<ExtArgs>
  }, ExtArgs["result"]["regionalReport"]>

  export type RegionalReportSelectScalar = {
    id?: boolean
    userId?: boolean
    regionId?: boolean
    municipalityId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type RegionalReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | RegionalReport$regionArgs<ExtArgs>
    municipality?: boolean | RegionalReport$municipalityArgs<ExtArgs>
    alerts?: boolean | RegionalReport$alertsArgs<ExtArgs>
    readReceipts?: boolean | RegionalReport$readReceiptsArgs<ExtArgs>
    _count?: boolean | RegionalReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionalReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    region?: boolean | RegionalReport$regionArgs<ExtArgs>
    municipality?: boolean | RegionalReport$municipalityArgs<ExtArgs>
  }

  export type $RegionalReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegionalReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      region: Prisma.$RegionPayload<ExtArgs> | null
      municipality: Prisma.$MunicipalityPayload<ExtArgs> | null
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      readReceipts: Prisma.$NewsReadReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      regionId: string | null
      municipalityId: string | null
      category: $Enums.NewsCategory
      priority: $Enums.Priority
      title: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["regionalReport"]>
    composites: {}
  }

  type RegionalReportGetPayload<S extends boolean | null | undefined | RegionalReportDefaultArgs> = $Result.GetResult<Prisma.$RegionalReportPayload, S>

  type RegionalReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionalReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegionalReportCountAggregateInputType | true
    }

  export interface RegionalReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegionalReport'], meta: { name: 'RegionalReport' } }
    /**
     * Find zero or one RegionalReport that matches the filter.
     * @param {RegionalReportFindUniqueArgs} args - Arguments to find a RegionalReport
     * @example
     * // Get one RegionalReport
     * const regionalReport = await prisma.regionalReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionalReportFindUniqueArgs>(args: SelectSubset<T, RegionalReportFindUniqueArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RegionalReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegionalReportFindUniqueOrThrowArgs} args - Arguments to find a RegionalReport
     * @example
     * // Get one RegionalReport
     * const regionalReport = await prisma.regionalReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionalReportFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionalReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RegionalReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportFindFirstArgs} args - Arguments to find a RegionalReport
     * @example
     * // Get one RegionalReport
     * const regionalReport = await prisma.regionalReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionalReportFindFirstArgs>(args?: SelectSubset<T, RegionalReportFindFirstArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RegionalReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportFindFirstOrThrowArgs} args - Arguments to find a RegionalReport
     * @example
     * // Get one RegionalReport
     * const regionalReport = await prisma.regionalReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionalReportFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionalReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RegionalReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionalReports
     * const regionalReports = await prisma.regionalReport.findMany()
     * 
     * // Get first 10 RegionalReports
     * const regionalReports = await prisma.regionalReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionalReportWithIdOnly = await prisma.regionalReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionalReportFindManyArgs>(args?: SelectSubset<T, RegionalReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RegionalReport.
     * @param {RegionalReportCreateArgs} args - Arguments to create a RegionalReport.
     * @example
     * // Create one RegionalReport
     * const RegionalReport = await prisma.regionalReport.create({
     *   data: {
     *     // ... data to create a RegionalReport
     *   }
     * })
     * 
     */
    create<T extends RegionalReportCreateArgs>(args: SelectSubset<T, RegionalReportCreateArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RegionalReports.
     * @param {RegionalReportCreateManyArgs} args - Arguments to create many RegionalReports.
     * @example
     * // Create many RegionalReports
     * const regionalReport = await prisma.regionalReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionalReportCreateManyArgs>(args?: SelectSubset<T, RegionalReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegionalReports and returns the data saved in the database.
     * @param {RegionalReportCreateManyAndReturnArgs} args - Arguments to create many RegionalReports.
     * @example
     * // Create many RegionalReports
     * const regionalReport = await prisma.regionalReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegionalReports and only return the `id`
     * const regionalReportWithIdOnly = await prisma.regionalReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionalReportCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionalReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RegionalReport.
     * @param {RegionalReportDeleteArgs} args - Arguments to delete one RegionalReport.
     * @example
     * // Delete one RegionalReport
     * const RegionalReport = await prisma.regionalReport.delete({
     *   where: {
     *     // ... filter to delete one RegionalReport
     *   }
     * })
     * 
     */
    delete<T extends RegionalReportDeleteArgs>(args: SelectSubset<T, RegionalReportDeleteArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RegionalReport.
     * @param {RegionalReportUpdateArgs} args - Arguments to update one RegionalReport.
     * @example
     * // Update one RegionalReport
     * const regionalReport = await prisma.regionalReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionalReportUpdateArgs>(args: SelectSubset<T, RegionalReportUpdateArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RegionalReports.
     * @param {RegionalReportDeleteManyArgs} args - Arguments to filter RegionalReports to delete.
     * @example
     * // Delete a few RegionalReports
     * const { count } = await prisma.regionalReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionalReportDeleteManyArgs>(args?: SelectSubset<T, RegionalReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionalReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionalReports
     * const regionalReport = await prisma.regionalReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionalReportUpdateManyArgs>(args: SelectSubset<T, RegionalReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegionalReport.
     * @param {RegionalReportUpsertArgs} args - Arguments to update or create a RegionalReport.
     * @example
     * // Update or create a RegionalReport
     * const regionalReport = await prisma.regionalReport.upsert({
     *   create: {
     *     // ... data to create a RegionalReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionalReport we want to update
     *   }
     * })
     */
    upsert<T extends RegionalReportUpsertArgs>(args: SelectSubset<T, RegionalReportUpsertArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RegionalReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportCountArgs} args - Arguments to filter RegionalReports to count.
     * @example
     * // Count the number of RegionalReports
     * const count = await prisma.regionalReport.count({
     *   where: {
     *     // ... the filter for the RegionalReports we want to count
     *   }
     * })
    **/
    count<T extends RegionalReportCountArgs>(
      args?: Subset<T, RegionalReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionalReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionalReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionalReportAggregateArgs>(args: Subset<T, RegionalReportAggregateArgs>): Prisma.PrismaPromise<GetRegionalReportAggregateType<T>>

    /**
     * Group by RegionalReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionalReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionalReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionalReportGroupByArgs['orderBy'] }
        : { orderBy?: RegionalReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionalReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionalReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegionalReport model
   */
  readonly fields: RegionalReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionalReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionalReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    region<T extends RegionalReport$regionArgs<ExtArgs> = {}>(args?: Subset<T, RegionalReport$regionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    municipality<T extends RegionalReport$municipalityArgs<ExtArgs> = {}>(args?: Subset<T, RegionalReport$municipalityArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    alerts<T extends RegionalReport$alertsArgs<ExtArgs> = {}>(args?: Subset<T, RegionalReport$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    readReceipts<T extends RegionalReport$readReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, RegionalReport$readReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegionalReport model
   */ 
  interface RegionalReportFieldRefs {
    readonly id: FieldRef<"RegionalReport", 'String'>
    readonly userId: FieldRef<"RegionalReport", 'String'>
    readonly regionId: FieldRef<"RegionalReport", 'String'>
    readonly municipalityId: FieldRef<"RegionalReport", 'String'>
    readonly category: FieldRef<"RegionalReport", 'NewsCategory'>
    readonly priority: FieldRef<"RegionalReport", 'Priority'>
    readonly title: FieldRef<"RegionalReport", 'String'>
    readonly content: FieldRef<"RegionalReport", 'String'>
    readonly createdAt: FieldRef<"RegionalReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegionalReport findUnique
   */
  export type RegionalReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * Filter, which RegionalReport to fetch.
     */
    where: RegionalReportWhereUniqueInput
  }

  /**
   * RegionalReport findUniqueOrThrow
   */
  export type RegionalReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * Filter, which RegionalReport to fetch.
     */
    where: RegionalReportWhereUniqueInput
  }

  /**
   * RegionalReport findFirst
   */
  export type RegionalReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * Filter, which RegionalReport to fetch.
     */
    where?: RegionalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionalReports to fetch.
     */
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionalReports.
     */
    cursor?: RegionalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionalReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionalReports.
     */
    distinct?: RegionalReportScalarFieldEnum | RegionalReportScalarFieldEnum[]
  }

  /**
   * RegionalReport findFirstOrThrow
   */
  export type RegionalReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * Filter, which RegionalReport to fetch.
     */
    where?: RegionalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionalReports to fetch.
     */
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionalReports.
     */
    cursor?: RegionalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionalReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionalReports.
     */
    distinct?: RegionalReportScalarFieldEnum | RegionalReportScalarFieldEnum[]
  }

  /**
   * RegionalReport findMany
   */
  export type RegionalReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * Filter, which RegionalReports to fetch.
     */
    where?: RegionalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionalReports to fetch.
     */
    orderBy?: RegionalReportOrderByWithRelationInput | RegionalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionalReports.
     */
    cursor?: RegionalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionalReports.
     */
    skip?: number
    distinct?: RegionalReportScalarFieldEnum | RegionalReportScalarFieldEnum[]
  }

  /**
   * RegionalReport create
   */
  export type RegionalReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * The data needed to create a RegionalReport.
     */
    data: XOR<RegionalReportCreateInput, RegionalReportUncheckedCreateInput>
  }

  /**
   * RegionalReport createMany
   */
  export type RegionalReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegionalReports.
     */
    data: RegionalReportCreateManyInput | RegionalReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegionalReport createManyAndReturn
   */
  export type RegionalReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RegionalReports.
     */
    data: RegionalReportCreateManyInput | RegionalReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegionalReport update
   */
  export type RegionalReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * The data needed to update a RegionalReport.
     */
    data: XOR<RegionalReportUpdateInput, RegionalReportUncheckedUpdateInput>
    /**
     * Choose, which RegionalReport to update.
     */
    where: RegionalReportWhereUniqueInput
  }

  /**
   * RegionalReport updateMany
   */
  export type RegionalReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegionalReports.
     */
    data: XOR<RegionalReportUpdateManyMutationInput, RegionalReportUncheckedUpdateManyInput>
    /**
     * Filter which RegionalReports to update
     */
    where?: RegionalReportWhereInput
  }

  /**
   * RegionalReport upsert
   */
  export type RegionalReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * The filter to search for the RegionalReport to update in case it exists.
     */
    where: RegionalReportWhereUniqueInput
    /**
     * In case the RegionalReport found by the `where` argument doesn't exist, create a new RegionalReport with this data.
     */
    create: XOR<RegionalReportCreateInput, RegionalReportUncheckedCreateInput>
    /**
     * In case the RegionalReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionalReportUpdateInput, RegionalReportUncheckedUpdateInput>
  }

  /**
   * RegionalReport delete
   */
  export type RegionalReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
    /**
     * Filter which RegionalReport to delete.
     */
    where: RegionalReportWhereUniqueInput
  }

  /**
   * RegionalReport deleteMany
   */
  export type RegionalReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionalReports to delete
     */
    where?: RegionalReportWhereInput
  }

  /**
   * RegionalReport.region
   */
  export type RegionalReport$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * RegionalReport.municipality
   */
  export type RegionalReport$municipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
  }

  /**
   * RegionalReport.alerts
   */
  export type RegionalReport$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * RegionalReport.readReceipts
   */
  export type RegionalReport$readReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    where?: NewsReadReceiptWhereInput
    orderBy?: NewsReadReceiptOrderByWithRelationInput | NewsReadReceiptOrderByWithRelationInput[]
    cursor?: NewsReadReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsReadReceiptScalarFieldEnum | NewsReadReceiptScalarFieldEnum[]
  }

  /**
   * RegionalReport without action
   */
  export type RegionalReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionalReport
     */
    select?: RegionalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionalReportInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    priority: $Enums.Priority | null
    status: string | null
    createdAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    priority: $Enums.Priority | null
    status: string | null
    createdAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    reportId: number
    priority: number
    status: number
    createdAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    reportId?: true
    priority?: true
    status?: true
    createdAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    reportId?: true
    priority?: true
    status?: true
    createdAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    reportId?: true
    priority?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    reportId: string
    priority: $Enums.Priority
    status: string
    createdAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    reportId?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      report: Prisma.$RegionalReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      priority: $Enums.Priority
      status: string
      createdAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends RegionalReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionalReportDefaultArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly reportId: FieldRef<"Alert", 'String'>
    readonly priority: FieldRef<"Alert", 'Priority'>
    readonly status: FieldRef<"Alert", 'String'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.ReportType | null
    format: $Enums.ReportFormat | null
    url: string | null
    hashSha256: string | null
    generatedById: string | null
    authorizedById: string | null
    regionId: string | null
    municipalityId: string | null
    generatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.ReportType | null
    format: $Enums.ReportFormat | null
    url: string | null
    hashSha256: string | null
    generatedById: string | null
    authorizedById: string | null
    regionId: string | null
    municipalityId: string | null
    generatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    code: number
    type: number
    format: number
    url: number
    hashSha256: number
    generatedById: number
    authorizedById: number
    regionId: number
    municipalityId: number
    metadata: number
    generatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    code?: true
    type?: true
    format?: true
    url?: true
    hashSha256?: true
    generatedById?: true
    authorizedById?: true
    regionId?: true
    municipalityId?: true
    generatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    code?: true
    type?: true
    format?: true
    url?: true
    hashSha256?: true
    generatedById?: true
    authorizedById?: true
    regionId?: true
    municipalityId?: true
    generatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    code?: true
    type?: true
    format?: true
    url?: true
    hashSha256?: true
    generatedById?: true
    authorizedById?: true
    regionId?: true
    municipalityId?: true
    metadata?: true
    generatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById: string | null
    regionId: string | null
    municipalityId: string | null
    metadata: JsonValue | null
    generatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    format?: boolean
    url?: boolean
    hashSha256?: boolean
    generatedById?: boolean
    authorizedById?: boolean
    regionId?: boolean
    municipalityId?: boolean
    metadata?: boolean
    generatedAt?: boolean
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>
    authorizedBy?: boolean | Report$authorizedByArgs<ExtArgs>
    region?: boolean | Report$regionArgs<ExtArgs>
    municipality?: boolean | Report$municipalityArgs<ExtArgs>
    deliveries?: boolean | Report$deliveriesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    format?: boolean
    url?: boolean
    hashSha256?: boolean
    generatedById?: boolean
    authorizedById?: boolean
    regionId?: boolean
    municipalityId?: boolean
    metadata?: boolean
    generatedAt?: boolean
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>
    authorizedBy?: boolean | Report$authorizedByArgs<ExtArgs>
    region?: boolean | Report$regionArgs<ExtArgs>
    municipality?: boolean | Report$municipalityArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    code?: boolean
    type?: boolean
    format?: boolean
    url?: boolean
    hashSha256?: boolean
    generatedById?: boolean
    authorizedById?: boolean
    regionId?: boolean
    municipalityId?: boolean
    metadata?: boolean
    generatedAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>
    authorizedBy?: boolean | Report$authorizedByArgs<ExtArgs>
    region?: boolean | Report$regionArgs<ExtArgs>
    municipality?: boolean | Report$municipalityArgs<ExtArgs>
    deliveries?: boolean | Report$deliveriesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedBy?: boolean | UserDefaultArgs<ExtArgs>
    authorizedBy?: boolean | Report$authorizedByArgs<ExtArgs>
    region?: boolean | Report$regionArgs<ExtArgs>
    municipality?: boolean | Report$municipalityArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      generatedBy: Prisma.$UserPayload<ExtArgs>
      authorizedBy: Prisma.$UserPayload<ExtArgs> | null
      region: Prisma.$RegionPayload<ExtArgs> | null
      municipality: Prisma.$MunicipalityPayload<ExtArgs> | null
      deliveries: Prisma.$ReportDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      type: $Enums.ReportType
      format: $Enums.ReportFormat
      url: string
      hashSha256: string
      generatedById: string
      authorizedById: string | null
      regionId: string | null
      municipalityId: string | null
      metadata: Prisma.JsonValue | null
      generatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    authorizedBy<T extends Report$authorizedByArgs<ExtArgs> = {}>(args?: Subset<T, Report$authorizedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    region<T extends Report$regionArgs<ExtArgs> = {}>(args?: Subset<T, Report$regionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    municipality<T extends Report$municipalityArgs<ExtArgs> = {}>(args?: Subset<T, Report$municipalityArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deliveries<T extends Report$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Report$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly code: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly format: FieldRef<"Report", 'ReportFormat'>
    readonly url: FieldRef<"Report", 'String'>
    readonly hashSha256: FieldRef<"Report", 'String'>
    readonly generatedById: FieldRef<"Report", 'String'>
    readonly authorizedById: FieldRef<"Report", 'String'>
    readonly regionId: FieldRef<"Report", 'String'>
    readonly municipalityId: FieldRef<"Report", 'String'>
    readonly metadata: FieldRef<"Report", 'Json'>
    readonly generatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.authorizedBy
   */
  export type Report$authorizedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.region
   */
  export type Report$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * Report.municipality
   */
  export type Report$municipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
  }

  /**
   * Report.deliveries
   */
  export type Report$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    where?: ReportDeliveryWhereInput
    orderBy?: ReportDeliveryOrderByWithRelationInput | ReportDeliveryOrderByWithRelationInput[]
    cursor?: ReportDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportDeliveryScalarFieldEnum | ReportDeliveryScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportDelivery
   */

  export type AggregateReportDelivery = {
    _count: ReportDeliveryCountAggregateOutputType | null
    _min: ReportDeliveryMinAggregateOutputType | null
    _max: ReportDeliveryMaxAggregateOutputType | null
  }

  export type ReportDeliveryMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    recipient: string | null
    channel: $Enums.DeliveryChannel | null
    status: string | null
    sentAt: Date | null
  }

  export type ReportDeliveryMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    recipient: string | null
    channel: $Enums.DeliveryChannel | null
    status: string | null
    sentAt: Date | null
  }

  export type ReportDeliveryCountAggregateOutputType = {
    id: number
    reportId: number
    recipient: number
    channel: number
    status: number
    sentAt: number
    _all: number
  }


  export type ReportDeliveryMinAggregateInputType = {
    id?: true
    reportId?: true
    recipient?: true
    channel?: true
    status?: true
    sentAt?: true
  }

  export type ReportDeliveryMaxAggregateInputType = {
    id?: true
    reportId?: true
    recipient?: true
    channel?: true
    status?: true
    sentAt?: true
  }

  export type ReportDeliveryCountAggregateInputType = {
    id?: true
    reportId?: true
    recipient?: true
    channel?: true
    status?: true
    sentAt?: true
    _all?: true
  }

  export type ReportDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDelivery to aggregate.
     */
    where?: ReportDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDeliveries to fetch.
     */
    orderBy?: ReportDeliveryOrderByWithRelationInput | ReportDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportDeliveries
    **/
    _count?: true | ReportDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportDeliveryMaxAggregateInputType
  }

  export type GetReportDeliveryAggregateType<T extends ReportDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateReportDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportDelivery[P]>
      : GetScalarType<T[P], AggregateReportDelivery[P]>
  }




  export type ReportDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDeliveryWhereInput
    orderBy?: ReportDeliveryOrderByWithAggregationInput | ReportDeliveryOrderByWithAggregationInput[]
    by: ReportDeliveryScalarFieldEnum[] | ReportDeliveryScalarFieldEnum
    having?: ReportDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportDeliveryCountAggregateInputType | true
    _min?: ReportDeliveryMinAggregateInputType
    _max?: ReportDeliveryMaxAggregateInputType
  }

  export type ReportDeliveryGroupByOutputType = {
    id: string
    reportId: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt: Date
    _count: ReportDeliveryCountAggregateOutputType | null
    _min: ReportDeliveryMinAggregateOutputType | null
    _max: ReportDeliveryMaxAggregateOutputType | null
  }

  type GetReportDeliveryGroupByPayload<T extends ReportDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], ReportDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type ReportDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    sentAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportDelivery"]>

  export type ReportDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    sentAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportDelivery"]>

  export type ReportDeliverySelectScalar = {
    id?: boolean
    reportId?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    sentAt?: boolean
  }

  export type ReportDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }
  export type ReportDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $ReportDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportDelivery"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      recipient: string
      channel: $Enums.DeliveryChannel
      status: string
      sentAt: Date
    }, ExtArgs["result"]["reportDelivery"]>
    composites: {}
  }

  type ReportDeliveryGetPayload<S extends boolean | null | undefined | ReportDeliveryDefaultArgs> = $Result.GetResult<Prisma.$ReportDeliveryPayload, S>

  type ReportDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportDeliveryCountAggregateInputType | true
    }

  export interface ReportDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportDelivery'], meta: { name: 'ReportDelivery' } }
    /**
     * Find zero or one ReportDelivery that matches the filter.
     * @param {ReportDeliveryFindUniqueArgs} args - Arguments to find a ReportDelivery
     * @example
     * // Get one ReportDelivery
     * const reportDelivery = await prisma.reportDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportDeliveryFindUniqueArgs>(args: SelectSubset<T, ReportDeliveryFindUniqueArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportDeliveryFindUniqueOrThrowArgs} args - Arguments to find a ReportDelivery
     * @example
     * // Get one ReportDelivery
     * const reportDelivery = await prisma.reportDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryFindFirstArgs} args - Arguments to find a ReportDelivery
     * @example
     * // Get one ReportDelivery
     * const reportDelivery = await prisma.reportDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportDeliveryFindFirstArgs>(args?: SelectSubset<T, ReportDeliveryFindFirstArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryFindFirstOrThrowArgs} args - Arguments to find a ReportDelivery
     * @example
     * // Get one ReportDelivery
     * const reportDelivery = await prisma.reportDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportDeliveries
     * const reportDeliveries = await prisma.reportDelivery.findMany()
     * 
     * // Get first 10 ReportDeliveries
     * const reportDeliveries = await prisma.reportDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportDeliveryWithIdOnly = await prisma.reportDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportDeliveryFindManyArgs>(args?: SelectSubset<T, ReportDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportDelivery.
     * @param {ReportDeliveryCreateArgs} args - Arguments to create a ReportDelivery.
     * @example
     * // Create one ReportDelivery
     * const ReportDelivery = await prisma.reportDelivery.create({
     *   data: {
     *     // ... data to create a ReportDelivery
     *   }
     * })
     * 
     */
    create<T extends ReportDeliveryCreateArgs>(args: SelectSubset<T, ReportDeliveryCreateArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportDeliveries.
     * @param {ReportDeliveryCreateManyArgs} args - Arguments to create many ReportDeliveries.
     * @example
     * // Create many ReportDeliveries
     * const reportDelivery = await prisma.reportDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportDeliveryCreateManyArgs>(args?: SelectSubset<T, ReportDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportDeliveries and returns the data saved in the database.
     * @param {ReportDeliveryCreateManyAndReturnArgs} args - Arguments to create many ReportDeliveries.
     * @example
     * // Create many ReportDeliveries
     * const reportDelivery = await prisma.reportDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportDeliveries and only return the `id`
     * const reportDeliveryWithIdOnly = await prisma.reportDelivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportDelivery.
     * @param {ReportDeliveryDeleteArgs} args - Arguments to delete one ReportDelivery.
     * @example
     * // Delete one ReportDelivery
     * const ReportDelivery = await prisma.reportDelivery.delete({
     *   where: {
     *     // ... filter to delete one ReportDelivery
     *   }
     * })
     * 
     */
    delete<T extends ReportDeliveryDeleteArgs>(args: SelectSubset<T, ReportDeliveryDeleteArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportDelivery.
     * @param {ReportDeliveryUpdateArgs} args - Arguments to update one ReportDelivery.
     * @example
     * // Update one ReportDelivery
     * const reportDelivery = await prisma.reportDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportDeliveryUpdateArgs>(args: SelectSubset<T, ReportDeliveryUpdateArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportDeliveries.
     * @param {ReportDeliveryDeleteManyArgs} args - Arguments to filter ReportDeliveries to delete.
     * @example
     * // Delete a few ReportDeliveries
     * const { count } = await prisma.reportDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeliveryDeleteManyArgs>(args?: SelectSubset<T, ReportDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportDeliveries
     * const reportDelivery = await prisma.reportDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportDeliveryUpdateManyArgs>(args: SelectSubset<T, ReportDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportDelivery.
     * @param {ReportDeliveryUpsertArgs} args - Arguments to update or create a ReportDelivery.
     * @example
     * // Update or create a ReportDelivery
     * const reportDelivery = await prisma.reportDelivery.upsert({
     *   create: {
     *     // ... data to create a ReportDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportDelivery we want to update
     *   }
     * })
     */
    upsert<T extends ReportDeliveryUpsertArgs>(args: SelectSubset<T, ReportDeliveryUpsertArgs<ExtArgs>>): Prisma__ReportDeliveryClient<$Result.GetResult<Prisma.$ReportDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryCountArgs} args - Arguments to filter ReportDeliveries to count.
     * @example
     * // Count the number of ReportDeliveries
     * const count = await prisma.reportDelivery.count({
     *   where: {
     *     // ... the filter for the ReportDeliveries we want to count
     *   }
     * })
    **/
    count<T extends ReportDeliveryCountArgs>(
      args?: Subset<T, ReportDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportDeliveryAggregateArgs>(args: Subset<T, ReportDeliveryAggregateArgs>): Prisma.PrismaPromise<GetReportDeliveryAggregateType<T>>

    /**
     * Group by ReportDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: ReportDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportDelivery model
   */
  readonly fields: ReportDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportDelivery model
   */ 
  interface ReportDeliveryFieldRefs {
    readonly id: FieldRef<"ReportDelivery", 'String'>
    readonly reportId: FieldRef<"ReportDelivery", 'String'>
    readonly recipient: FieldRef<"ReportDelivery", 'String'>
    readonly channel: FieldRef<"ReportDelivery", 'DeliveryChannel'>
    readonly status: FieldRef<"ReportDelivery", 'String'>
    readonly sentAt: FieldRef<"ReportDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportDelivery findUnique
   */
  export type ReportDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which ReportDelivery to fetch.
     */
    where: ReportDeliveryWhereUniqueInput
  }

  /**
   * ReportDelivery findUniqueOrThrow
   */
  export type ReportDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which ReportDelivery to fetch.
     */
    where: ReportDeliveryWhereUniqueInput
  }

  /**
   * ReportDelivery findFirst
   */
  export type ReportDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which ReportDelivery to fetch.
     */
    where?: ReportDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDeliveries to fetch.
     */
    orderBy?: ReportDeliveryOrderByWithRelationInput | ReportDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDeliveries.
     */
    cursor?: ReportDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDeliveries.
     */
    distinct?: ReportDeliveryScalarFieldEnum | ReportDeliveryScalarFieldEnum[]
  }

  /**
   * ReportDelivery findFirstOrThrow
   */
  export type ReportDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which ReportDelivery to fetch.
     */
    where?: ReportDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDeliveries to fetch.
     */
    orderBy?: ReportDeliveryOrderByWithRelationInput | ReportDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDeliveries.
     */
    cursor?: ReportDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDeliveries.
     */
    distinct?: ReportDeliveryScalarFieldEnum | ReportDeliveryScalarFieldEnum[]
  }

  /**
   * ReportDelivery findMany
   */
  export type ReportDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which ReportDeliveries to fetch.
     */
    where?: ReportDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDeliveries to fetch.
     */
    orderBy?: ReportDeliveryOrderByWithRelationInput | ReportDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportDeliveries.
     */
    cursor?: ReportDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDeliveries.
     */
    skip?: number
    distinct?: ReportDeliveryScalarFieldEnum | ReportDeliveryScalarFieldEnum[]
  }

  /**
   * ReportDelivery create
   */
  export type ReportDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportDelivery.
     */
    data: XOR<ReportDeliveryCreateInput, ReportDeliveryUncheckedCreateInput>
  }

  /**
   * ReportDelivery createMany
   */
  export type ReportDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportDeliveries.
     */
    data: ReportDeliveryCreateManyInput | ReportDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportDelivery createManyAndReturn
   */
  export type ReportDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportDeliveries.
     */
    data: ReportDeliveryCreateManyInput | ReportDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportDelivery update
   */
  export type ReportDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportDelivery.
     */
    data: XOR<ReportDeliveryUpdateInput, ReportDeliveryUncheckedUpdateInput>
    /**
     * Choose, which ReportDelivery to update.
     */
    where: ReportDeliveryWhereUniqueInput
  }

  /**
   * ReportDelivery updateMany
   */
  export type ReportDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportDeliveries.
     */
    data: XOR<ReportDeliveryUpdateManyMutationInput, ReportDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which ReportDeliveries to update
     */
    where?: ReportDeliveryWhereInput
  }

  /**
   * ReportDelivery upsert
   */
  export type ReportDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportDelivery to update in case it exists.
     */
    where: ReportDeliveryWhereUniqueInput
    /**
     * In case the ReportDelivery found by the `where` argument doesn't exist, create a new ReportDelivery with this data.
     */
    create: XOR<ReportDeliveryCreateInput, ReportDeliveryUncheckedCreateInput>
    /**
     * In case the ReportDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportDeliveryUpdateInput, ReportDeliveryUncheckedUpdateInput>
  }

  /**
   * ReportDelivery delete
   */
  export type ReportDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
    /**
     * Filter which ReportDelivery to delete.
     */
    where: ReportDeliveryWhereUniqueInput
  }

  /**
   * ReportDelivery deleteMany
   */
  export type ReportDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDeliveries to delete
     */
    where?: ReportDeliveryWhereInput
  }

  /**
   * ReportDelivery without action
   */
  export type ReportDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDelivery
     */
    select?: ReportDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model NewsReadReceipt
   */

  export type AggregateNewsReadReceipt = {
    _count: NewsReadReceiptCountAggregateOutputType | null
    _min: NewsReadReceiptMinAggregateOutputType | null
    _max: NewsReadReceiptMaxAggregateOutputType | null
  }

  export type NewsReadReceiptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    reportId: string | null
    readAt: Date | null
  }

  export type NewsReadReceiptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    reportId: string | null
    readAt: Date | null
  }

  export type NewsReadReceiptCountAggregateOutputType = {
    id: number
    userId: number
    reportId: number
    readAt: number
    _all: number
  }


  export type NewsReadReceiptMinAggregateInputType = {
    id?: true
    userId?: true
    reportId?: true
    readAt?: true
  }

  export type NewsReadReceiptMaxAggregateInputType = {
    id?: true
    userId?: true
    reportId?: true
    readAt?: true
  }

  export type NewsReadReceiptCountAggregateInputType = {
    id?: true
    userId?: true
    reportId?: true
    readAt?: true
    _all?: true
  }

  export type NewsReadReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsReadReceipt to aggregate.
     */
    where?: NewsReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsReadReceipts to fetch.
     */
    orderBy?: NewsReadReceiptOrderByWithRelationInput | NewsReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsReadReceipts
    **/
    _count?: true | NewsReadReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsReadReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsReadReceiptMaxAggregateInputType
  }

  export type GetNewsReadReceiptAggregateType<T extends NewsReadReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsReadReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsReadReceipt[P]>
      : GetScalarType<T[P], AggregateNewsReadReceipt[P]>
  }




  export type NewsReadReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsReadReceiptWhereInput
    orderBy?: NewsReadReceiptOrderByWithAggregationInput | NewsReadReceiptOrderByWithAggregationInput[]
    by: NewsReadReceiptScalarFieldEnum[] | NewsReadReceiptScalarFieldEnum
    having?: NewsReadReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsReadReceiptCountAggregateInputType | true
    _min?: NewsReadReceiptMinAggregateInputType
    _max?: NewsReadReceiptMaxAggregateInputType
  }

  export type NewsReadReceiptGroupByOutputType = {
    id: string
    userId: string
    reportId: string
    readAt: Date
    _count: NewsReadReceiptCountAggregateOutputType | null
    _min: NewsReadReceiptMinAggregateOutputType | null
    _max: NewsReadReceiptMaxAggregateOutputType | null
  }

  type GetNewsReadReceiptGroupByPayload<T extends NewsReadReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsReadReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsReadReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsReadReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], NewsReadReceiptGroupByOutputType[P]>
        }
      >
    >


  export type NewsReadReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportId?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsReadReceipt"]>

  export type NewsReadReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportId?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsReadReceipt"]>

  export type NewsReadReceiptSelectScalar = {
    id?: boolean
    userId?: boolean
    reportId?: boolean
    readAt?: boolean
  }

  export type NewsReadReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }
  export type NewsReadReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | RegionalReportDefaultArgs<ExtArgs>
  }

  export type $NewsReadReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsReadReceipt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      report: Prisma.$RegionalReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      reportId: string
      readAt: Date
    }, ExtArgs["result"]["newsReadReceipt"]>
    composites: {}
  }

  type NewsReadReceiptGetPayload<S extends boolean | null | undefined | NewsReadReceiptDefaultArgs> = $Result.GetResult<Prisma.$NewsReadReceiptPayload, S>

  type NewsReadReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsReadReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsReadReceiptCountAggregateInputType | true
    }

  export interface NewsReadReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsReadReceipt'], meta: { name: 'NewsReadReceipt' } }
    /**
     * Find zero or one NewsReadReceipt that matches the filter.
     * @param {NewsReadReceiptFindUniqueArgs} args - Arguments to find a NewsReadReceipt
     * @example
     * // Get one NewsReadReceipt
     * const newsReadReceipt = await prisma.newsReadReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsReadReceiptFindUniqueArgs>(args: SelectSubset<T, NewsReadReceiptFindUniqueArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsReadReceipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsReadReceiptFindUniqueOrThrowArgs} args - Arguments to find a NewsReadReceipt
     * @example
     * // Get one NewsReadReceipt
     * const newsReadReceipt = await prisma.newsReadReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsReadReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsReadReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsReadReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptFindFirstArgs} args - Arguments to find a NewsReadReceipt
     * @example
     * // Get one NewsReadReceipt
     * const newsReadReceipt = await prisma.newsReadReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsReadReceiptFindFirstArgs>(args?: SelectSubset<T, NewsReadReceiptFindFirstArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsReadReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptFindFirstOrThrowArgs} args - Arguments to find a NewsReadReceipt
     * @example
     * // Get one NewsReadReceipt
     * const newsReadReceipt = await prisma.newsReadReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsReadReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsReadReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsReadReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsReadReceipts
     * const newsReadReceipts = await prisma.newsReadReceipt.findMany()
     * 
     * // Get first 10 NewsReadReceipts
     * const newsReadReceipts = await prisma.newsReadReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsReadReceiptWithIdOnly = await prisma.newsReadReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsReadReceiptFindManyArgs>(args?: SelectSubset<T, NewsReadReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsReadReceipt.
     * @param {NewsReadReceiptCreateArgs} args - Arguments to create a NewsReadReceipt.
     * @example
     * // Create one NewsReadReceipt
     * const NewsReadReceipt = await prisma.newsReadReceipt.create({
     *   data: {
     *     // ... data to create a NewsReadReceipt
     *   }
     * })
     * 
     */
    create<T extends NewsReadReceiptCreateArgs>(args: SelectSubset<T, NewsReadReceiptCreateArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsReadReceipts.
     * @param {NewsReadReceiptCreateManyArgs} args - Arguments to create many NewsReadReceipts.
     * @example
     * // Create many NewsReadReceipts
     * const newsReadReceipt = await prisma.newsReadReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsReadReceiptCreateManyArgs>(args?: SelectSubset<T, NewsReadReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsReadReceipts and returns the data saved in the database.
     * @param {NewsReadReceiptCreateManyAndReturnArgs} args - Arguments to create many NewsReadReceipts.
     * @example
     * // Create many NewsReadReceipts
     * const newsReadReceipt = await prisma.newsReadReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsReadReceipts and only return the `id`
     * const newsReadReceiptWithIdOnly = await prisma.newsReadReceipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsReadReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsReadReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsReadReceipt.
     * @param {NewsReadReceiptDeleteArgs} args - Arguments to delete one NewsReadReceipt.
     * @example
     * // Delete one NewsReadReceipt
     * const NewsReadReceipt = await prisma.newsReadReceipt.delete({
     *   where: {
     *     // ... filter to delete one NewsReadReceipt
     *   }
     * })
     * 
     */
    delete<T extends NewsReadReceiptDeleteArgs>(args: SelectSubset<T, NewsReadReceiptDeleteArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsReadReceipt.
     * @param {NewsReadReceiptUpdateArgs} args - Arguments to update one NewsReadReceipt.
     * @example
     * // Update one NewsReadReceipt
     * const newsReadReceipt = await prisma.newsReadReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsReadReceiptUpdateArgs>(args: SelectSubset<T, NewsReadReceiptUpdateArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsReadReceipts.
     * @param {NewsReadReceiptDeleteManyArgs} args - Arguments to filter NewsReadReceipts to delete.
     * @example
     * // Delete a few NewsReadReceipts
     * const { count } = await prisma.newsReadReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsReadReceiptDeleteManyArgs>(args?: SelectSubset<T, NewsReadReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsReadReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsReadReceipts
     * const newsReadReceipt = await prisma.newsReadReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsReadReceiptUpdateManyArgs>(args: SelectSubset<T, NewsReadReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsReadReceipt.
     * @param {NewsReadReceiptUpsertArgs} args - Arguments to update or create a NewsReadReceipt.
     * @example
     * // Update or create a NewsReadReceipt
     * const newsReadReceipt = await prisma.newsReadReceipt.upsert({
     *   create: {
     *     // ... data to create a NewsReadReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsReadReceipt we want to update
     *   }
     * })
     */
    upsert<T extends NewsReadReceiptUpsertArgs>(args: SelectSubset<T, NewsReadReceiptUpsertArgs<ExtArgs>>): Prisma__NewsReadReceiptClient<$Result.GetResult<Prisma.$NewsReadReceiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsReadReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptCountArgs} args - Arguments to filter NewsReadReceipts to count.
     * @example
     * // Count the number of NewsReadReceipts
     * const count = await prisma.newsReadReceipt.count({
     *   where: {
     *     // ... the filter for the NewsReadReceipts we want to count
     *   }
     * })
    **/
    count<T extends NewsReadReceiptCountArgs>(
      args?: Subset<T, NewsReadReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsReadReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsReadReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsReadReceiptAggregateArgs>(args: Subset<T, NewsReadReceiptAggregateArgs>): Prisma.PrismaPromise<GetNewsReadReceiptAggregateType<T>>

    /**
     * Group by NewsReadReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsReadReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsReadReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsReadReceiptGroupByArgs['orderBy'] }
        : { orderBy?: NewsReadReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsReadReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsReadReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsReadReceipt model
   */
  readonly fields: NewsReadReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsReadReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsReadReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    report<T extends RegionalReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionalReportDefaultArgs<ExtArgs>>): Prisma__RegionalReportClient<$Result.GetResult<Prisma.$RegionalReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsReadReceipt model
   */ 
  interface NewsReadReceiptFieldRefs {
    readonly id: FieldRef<"NewsReadReceipt", 'String'>
    readonly userId: FieldRef<"NewsReadReceipt", 'String'>
    readonly reportId: FieldRef<"NewsReadReceipt", 'String'>
    readonly readAt: FieldRef<"NewsReadReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsReadReceipt findUnique
   */
  export type NewsReadReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NewsReadReceipt to fetch.
     */
    where: NewsReadReceiptWhereUniqueInput
  }

  /**
   * NewsReadReceipt findUniqueOrThrow
   */
  export type NewsReadReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NewsReadReceipt to fetch.
     */
    where: NewsReadReceiptWhereUniqueInput
  }

  /**
   * NewsReadReceipt findFirst
   */
  export type NewsReadReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NewsReadReceipt to fetch.
     */
    where?: NewsReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsReadReceipts to fetch.
     */
    orderBy?: NewsReadReceiptOrderByWithRelationInput | NewsReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsReadReceipts.
     */
    cursor?: NewsReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsReadReceipts.
     */
    distinct?: NewsReadReceiptScalarFieldEnum | NewsReadReceiptScalarFieldEnum[]
  }

  /**
   * NewsReadReceipt findFirstOrThrow
   */
  export type NewsReadReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NewsReadReceipt to fetch.
     */
    where?: NewsReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsReadReceipts to fetch.
     */
    orderBy?: NewsReadReceiptOrderByWithRelationInput | NewsReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsReadReceipts.
     */
    cursor?: NewsReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsReadReceipts.
     */
    distinct?: NewsReadReceiptScalarFieldEnum | NewsReadReceiptScalarFieldEnum[]
  }

  /**
   * NewsReadReceipt findMany
   */
  export type NewsReadReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NewsReadReceipts to fetch.
     */
    where?: NewsReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsReadReceipts to fetch.
     */
    orderBy?: NewsReadReceiptOrderByWithRelationInput | NewsReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsReadReceipts.
     */
    cursor?: NewsReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsReadReceipts.
     */
    skip?: number
    distinct?: NewsReadReceiptScalarFieldEnum | NewsReadReceiptScalarFieldEnum[]
  }

  /**
   * NewsReadReceipt create
   */
  export type NewsReadReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsReadReceipt.
     */
    data: XOR<NewsReadReceiptCreateInput, NewsReadReceiptUncheckedCreateInput>
  }

  /**
   * NewsReadReceipt createMany
   */
  export type NewsReadReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsReadReceipts.
     */
    data: NewsReadReceiptCreateManyInput | NewsReadReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsReadReceipt createManyAndReturn
   */
  export type NewsReadReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsReadReceipts.
     */
    data: NewsReadReceiptCreateManyInput | NewsReadReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsReadReceipt update
   */
  export type NewsReadReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsReadReceipt.
     */
    data: XOR<NewsReadReceiptUpdateInput, NewsReadReceiptUncheckedUpdateInput>
    /**
     * Choose, which NewsReadReceipt to update.
     */
    where: NewsReadReceiptWhereUniqueInput
  }

  /**
   * NewsReadReceipt updateMany
   */
  export type NewsReadReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsReadReceipts.
     */
    data: XOR<NewsReadReceiptUpdateManyMutationInput, NewsReadReceiptUncheckedUpdateManyInput>
    /**
     * Filter which NewsReadReceipts to update
     */
    where?: NewsReadReceiptWhereInput
  }

  /**
   * NewsReadReceipt upsert
   */
  export type NewsReadReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsReadReceipt to update in case it exists.
     */
    where: NewsReadReceiptWhereUniqueInput
    /**
     * In case the NewsReadReceipt found by the `where` argument doesn't exist, create a new NewsReadReceipt with this data.
     */
    create: XOR<NewsReadReceiptCreateInput, NewsReadReceiptUncheckedCreateInput>
    /**
     * In case the NewsReadReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsReadReceiptUpdateInput, NewsReadReceiptUncheckedUpdateInput>
  }

  /**
   * NewsReadReceipt delete
   */
  export type NewsReadReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
    /**
     * Filter which NewsReadReceipt to delete.
     */
    where: NewsReadReceiptWhereUniqueInput
  }

  /**
   * NewsReadReceipt deleteMany
   */
  export type NewsReadReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsReadReceipts to delete
     */
    where?: NewsReadReceiptWhereInput
  }

  /**
   * NewsReadReceipt without action
   */
  export type NewsReadReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsReadReceipt
     */
    select?: NewsReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsReadReceiptInclude<ExtArgs> | null
  }


  /**
   * Model Visit
   */

  export type AggregateVisit = {
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  export type VisitAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    gpsAccuracy: number | null
  }

  export type VisitSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    gpsAccuracy: number | null
  }

  export type VisitMinAggregateOutputType = {
    id: string | null
    source: $Enums.VisitSource | null
    reliability: $Enums.VisitReliability | null
    citizenId: string | null
    fullName: string | null
    addressText: string | null
    phone: string | null
    latitude: number | null
    longitude: number | null
    gpsAccuracy: number | null
    verifiedAt: Date | null
    status: $Enums.VisitStatus | null
    priority: $Enums.Priority | null
    regionId: string | null
    municipalityId: string | null
    vereda: string | null
    assignedToId: string | null
    assignedById: string | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitMaxAggregateOutputType = {
    id: string | null
    source: $Enums.VisitSource | null
    reliability: $Enums.VisitReliability | null
    citizenId: string | null
    fullName: string | null
    addressText: string | null
    phone: string | null
    latitude: number | null
    longitude: number | null
    gpsAccuracy: number | null
    verifiedAt: Date | null
    status: $Enums.VisitStatus | null
    priority: $Enums.Priority | null
    regionId: string | null
    municipalityId: string | null
    vereda: string | null
    assignedToId: string | null
    assignedById: string | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCountAggregateOutputType = {
    id: number
    source: number
    reliability: number
    citizenId: number
    fullName: number
    addressText: number
    phone: number
    latitude: number
    longitude: number
    gpsAccuracy: number
    verifiedAt: number
    status: number
    priority: number
    regionId: number
    municipalityId: number
    vereda: number
    assignedToId: number
    assignedById: number
    assignedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    gpsAccuracy?: true
  }

  export type VisitSumAggregateInputType = {
    latitude?: true
    longitude?: true
    gpsAccuracy?: true
  }

  export type VisitMinAggregateInputType = {
    id?: true
    source?: true
    reliability?: true
    citizenId?: true
    fullName?: true
    addressText?: true
    phone?: true
    latitude?: true
    longitude?: true
    gpsAccuracy?: true
    verifiedAt?: true
    status?: true
    priority?: true
    regionId?: true
    municipalityId?: true
    vereda?: true
    assignedToId?: true
    assignedById?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitMaxAggregateInputType = {
    id?: true
    source?: true
    reliability?: true
    citizenId?: true
    fullName?: true
    addressText?: true
    phone?: true
    latitude?: true
    longitude?: true
    gpsAccuracy?: true
    verifiedAt?: true
    status?: true
    priority?: true
    regionId?: true
    municipalityId?: true
    vereda?: true
    assignedToId?: true
    assignedById?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCountAggregateInputType = {
    id?: true
    source?: true
    reliability?: true
    citizenId?: true
    fullName?: true
    addressText?: true
    phone?: true
    latitude?: true
    longitude?: true
    gpsAccuracy?: true
    verifiedAt?: true
    status?: true
    priority?: true
    regionId?: true
    municipalityId?: true
    vereda?: true
    assignedToId?: true
    assignedById?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visit to aggregate.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visits
    **/
    _count?: true | VisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitMaxAggregateInputType
  }

  export type GetVisitAggregateType<T extends VisitAggregateArgs> = {
        [P in keyof T & keyof AggregateVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisit[P]>
      : GetScalarType<T[P], AggregateVisit[P]>
  }




  export type VisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithAggregationInput | VisitOrderByWithAggregationInput[]
    by: VisitScalarFieldEnum[] | VisitScalarFieldEnum
    having?: VisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCountAggregateInputType | true
    _avg?: VisitAvgAggregateInputType
    _sum?: VisitSumAggregateInputType
    _min?: VisitMinAggregateInputType
    _max?: VisitMaxAggregateInputType
  }

  export type VisitGroupByOutputType = {
    id: string
    source: $Enums.VisitSource
    reliability: $Enums.VisitReliability
    citizenId: string | null
    fullName: string | null
    addressText: string
    phone: string | null
    latitude: number | null
    longitude: number | null
    gpsAccuracy: number | null
    verifiedAt: Date | null
    status: $Enums.VisitStatus
    priority: $Enums.Priority
    regionId: string
    municipalityId: string | null
    vereda: string | null
    assignedToId: string | null
    assignedById: string | null
    assignedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  type GetVisitGroupByPayload<T extends VisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitGroupByOutputType[P]>
            : GetScalarType<T[P], VisitGroupByOutputType[P]>
        }
      >
    >


  export type VisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    reliability?: boolean
    citizenId?: boolean
    fullName?: boolean
    addressText?: boolean
    phone?: boolean
    latitude?: boolean
    longitude?: boolean
    gpsAccuracy?: boolean
    verifiedAt?: boolean
    status?: boolean
    priority?: boolean
    regionId?: boolean
    municipalityId?: boolean
    vereda?: boolean
    assignedToId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    municipality?: boolean | Visit$municipalityArgs<ExtArgs>
    assignedTo?: boolean | Visit$assignedToArgs<ExtArgs>
    assignedBy?: boolean | Visit$assignedByArgs<ExtArgs>
    logs?: boolean | Visit$logsArgs<ExtArgs>
    _count?: boolean | VisitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    reliability?: boolean
    citizenId?: boolean
    fullName?: boolean
    addressText?: boolean
    phone?: boolean
    latitude?: boolean
    longitude?: boolean
    gpsAccuracy?: boolean
    verifiedAt?: boolean
    status?: boolean
    priority?: boolean
    regionId?: boolean
    municipalityId?: boolean
    vereda?: boolean
    assignedToId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    municipality?: boolean | Visit$municipalityArgs<ExtArgs>
    assignedTo?: boolean | Visit$assignedToArgs<ExtArgs>
    assignedBy?: boolean | Visit$assignedByArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectScalar = {
    id?: boolean
    source?: boolean
    reliability?: boolean
    citizenId?: boolean
    fullName?: boolean
    addressText?: boolean
    phone?: boolean
    latitude?: boolean
    longitude?: boolean
    gpsAccuracy?: boolean
    verifiedAt?: boolean
    status?: boolean
    priority?: boolean
    regionId?: boolean
    municipalityId?: boolean
    vereda?: boolean
    assignedToId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    municipality?: boolean | Visit$municipalityArgs<ExtArgs>
    assignedTo?: boolean | Visit$assignedToArgs<ExtArgs>
    assignedBy?: boolean | Visit$assignedByArgs<ExtArgs>
    logs?: boolean | Visit$logsArgs<ExtArgs>
    _count?: boolean | VisitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    municipality?: boolean | Visit$municipalityArgs<ExtArgs>
    assignedTo?: boolean | Visit$assignedToArgs<ExtArgs>
    assignedBy?: boolean | Visit$assignedByArgs<ExtArgs>
  }

  export type $VisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visit"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      municipality: Prisma.$MunicipalityPayload<ExtArgs> | null
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      assignedBy: Prisma.$UserPayload<ExtArgs> | null
      logs: Prisma.$VisitLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: $Enums.VisitSource
      reliability: $Enums.VisitReliability
      citizenId: string | null
      fullName: string | null
      addressText: string
      phone: string | null
      latitude: number | null
      longitude: number | null
      gpsAccuracy: number | null
      verifiedAt: Date | null
      status: $Enums.VisitStatus
      priority: $Enums.Priority
      regionId: string
      municipalityId: string | null
      vereda: string | null
      assignedToId: string | null
      assignedById: string | null
      assignedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visit"]>
    composites: {}
  }

  type VisitGetPayload<S extends boolean | null | undefined | VisitDefaultArgs> = $Result.GetResult<Prisma.$VisitPayload, S>

  type VisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitCountAggregateInputType | true
    }

  export interface VisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visit'], meta: { name: 'Visit' } }
    /**
     * Find zero or one Visit that matches the filter.
     * @param {VisitFindUniqueArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitFindUniqueArgs>(args: SelectSubset<T, VisitFindUniqueArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Visit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitFindUniqueOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Visit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitFindFirstArgs>(args?: SelectSubset<T, VisitFindFirstArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Visit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visits
     * const visits = await prisma.visit.findMany()
     * 
     * // Get first 10 Visits
     * const visits = await prisma.visit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitWithIdOnly = await prisma.visit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitFindManyArgs>(args?: SelectSubset<T, VisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Visit.
     * @param {VisitCreateArgs} args - Arguments to create a Visit.
     * @example
     * // Create one Visit
     * const Visit = await prisma.visit.create({
     *   data: {
     *     // ... data to create a Visit
     *   }
     * })
     * 
     */
    create<T extends VisitCreateArgs>(args: SelectSubset<T, VisitCreateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Visits.
     * @param {VisitCreateManyArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCreateManyArgs>(args?: SelectSubset<T, VisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visits and returns the data saved in the database.
     * @param {VisitCreateManyAndReturnArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visits and only return the `id`
     * const visitWithIdOnly = await prisma.visit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Visit.
     * @param {VisitDeleteArgs} args - Arguments to delete one Visit.
     * @example
     * // Delete one Visit
     * const Visit = await prisma.visit.delete({
     *   where: {
     *     // ... filter to delete one Visit
     *   }
     * })
     * 
     */
    delete<T extends VisitDeleteArgs>(args: SelectSubset<T, VisitDeleteArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Visit.
     * @param {VisitUpdateArgs} args - Arguments to update one Visit.
     * @example
     * // Update one Visit
     * const visit = await prisma.visit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitUpdateArgs>(args: SelectSubset<T, VisitUpdateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Visits.
     * @param {VisitDeleteManyArgs} args - Arguments to filter Visits to delete.
     * @example
     * // Delete a few Visits
     * const { count } = await prisma.visit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitDeleteManyArgs>(args?: SelectSubset<T, VisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visits
     * const visit = await prisma.visit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitUpdateManyArgs>(args: SelectSubset<T, VisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visit.
     * @param {VisitUpsertArgs} args - Arguments to update or create a Visit.
     * @example
     * // Update or create a Visit
     * const visit = await prisma.visit.upsert({
     *   create: {
     *     // ... data to create a Visit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visit we want to update
     *   }
     * })
     */
    upsert<T extends VisitUpsertArgs>(args: SelectSubset<T, VisitUpsertArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCountArgs} args - Arguments to filter Visits to count.
     * @example
     * // Count the number of Visits
     * const count = await prisma.visit.count({
     *   where: {
     *     // ... the filter for the Visits we want to count
     *   }
     * })
    **/
    count<T extends VisitCountArgs>(
      args?: Subset<T, VisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitAggregateArgs>(args: Subset<T, VisitAggregateArgs>): Prisma.PrismaPromise<GetVisitAggregateType<T>>

    /**
     * Group by Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitGroupByArgs['orderBy'] }
        : { orderBy?: VisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visit model
   */
  readonly fields: VisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    municipality<T extends Visit$municipalityArgs<ExtArgs> = {}>(args?: Subset<T, Visit$municipalityArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedTo<T extends Visit$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Visit$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedBy<T extends Visit$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, Visit$assignedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Visit$logsArgs<ExtArgs> = {}>(args?: Subset<T, Visit$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visit model
   */ 
  interface VisitFieldRefs {
    readonly id: FieldRef<"Visit", 'String'>
    readonly source: FieldRef<"Visit", 'VisitSource'>
    readonly reliability: FieldRef<"Visit", 'VisitReliability'>
    readonly citizenId: FieldRef<"Visit", 'String'>
    readonly fullName: FieldRef<"Visit", 'String'>
    readonly addressText: FieldRef<"Visit", 'String'>
    readonly phone: FieldRef<"Visit", 'String'>
    readonly latitude: FieldRef<"Visit", 'Float'>
    readonly longitude: FieldRef<"Visit", 'Float'>
    readonly gpsAccuracy: FieldRef<"Visit", 'Float'>
    readonly verifiedAt: FieldRef<"Visit", 'DateTime'>
    readonly status: FieldRef<"Visit", 'VisitStatus'>
    readonly priority: FieldRef<"Visit", 'Priority'>
    readonly regionId: FieldRef<"Visit", 'String'>
    readonly municipalityId: FieldRef<"Visit", 'String'>
    readonly vereda: FieldRef<"Visit", 'String'>
    readonly assignedToId: FieldRef<"Visit", 'String'>
    readonly assignedById: FieldRef<"Visit", 'String'>
    readonly assignedAt: FieldRef<"Visit", 'DateTime'>
    readonly createdAt: FieldRef<"Visit", 'DateTime'>
    readonly updatedAt: FieldRef<"Visit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visit findUnique
   */
  export type VisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findUniqueOrThrow
   */
  export type VisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findFirst
   */
  export type VisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findFirstOrThrow
   */
  export type VisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findMany
   */
  export type VisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit create
   */
  export type VisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to create a Visit.
     */
    data: XOR<VisitCreateInput, VisitUncheckedCreateInput>
  }

  /**
   * Visit createMany
   */
  export type VisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visit createManyAndReturn
   */
  export type VisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visit update
   */
  export type VisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to update a Visit.
     */
    data: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
    /**
     * Choose, which Visit to update.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit updateMany
   */
  export type VisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitWhereInput
  }

  /**
   * Visit upsert
   */
  export type VisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The filter to search for the Visit to update in case it exists.
     */
    where: VisitWhereUniqueInput
    /**
     * In case the Visit found by the `where` argument doesn't exist, create a new Visit with this data.
     */
    create: XOR<VisitCreateInput, VisitUncheckedCreateInput>
    /**
     * In case the Visit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
  }

  /**
   * Visit delete
   */
  export type VisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter which Visit to delete.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit deleteMany
   */
  export type VisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visits to delete
     */
    where?: VisitWhereInput
  }

  /**
   * Visit.municipality
   */
  export type Visit$municipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
  }

  /**
   * Visit.assignedTo
   */
  export type Visit$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Visit.assignedBy
   */
  export type Visit$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Visit.logs
   */
  export type Visit$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    where?: VisitLogWhereInput
    orderBy?: VisitLogOrderByWithRelationInput | VisitLogOrderByWithRelationInput[]
    cursor?: VisitLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitLogScalarFieldEnum | VisitLogScalarFieldEnum[]
  }

  /**
   * Visit without action
   */
  export type VisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
  }


  /**
   * Model VisitLog
   */

  export type AggregateVisitLog = {
    _count: VisitLogCountAggregateOutputType | null
    _min: VisitLogMinAggregateOutputType | null
    _max: VisitLogMaxAggregateOutputType | null
  }

  export type VisitLogMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    userId: string | null
    action: string | null
    timestamp: Date | null
  }

  export type VisitLogMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    userId: string | null
    action: string | null
    timestamp: Date | null
  }

  export type VisitLogCountAggregateOutputType = {
    id: number
    visitId: number
    userId: number
    action: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type VisitLogMinAggregateInputType = {
    id?: true
    visitId?: true
    userId?: true
    action?: true
    timestamp?: true
  }

  export type VisitLogMaxAggregateInputType = {
    id?: true
    visitId?: true
    userId?: true
    action?: true
    timestamp?: true
  }

  export type VisitLogCountAggregateInputType = {
    id?: true
    visitId?: true
    userId?: true
    action?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type VisitLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitLog to aggregate.
     */
    where?: VisitLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitLogs to fetch.
     */
    orderBy?: VisitLogOrderByWithRelationInput | VisitLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitLogs
    **/
    _count?: true | VisitLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitLogMaxAggregateInputType
  }

  export type GetVisitLogAggregateType<T extends VisitLogAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitLog[P]>
      : GetScalarType<T[P], AggregateVisitLog[P]>
  }




  export type VisitLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitLogWhereInput
    orderBy?: VisitLogOrderByWithAggregationInput | VisitLogOrderByWithAggregationInput[]
    by: VisitLogScalarFieldEnum[] | VisitLogScalarFieldEnum
    having?: VisitLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitLogCountAggregateInputType | true
    _min?: VisitLogMinAggregateInputType
    _max?: VisitLogMaxAggregateInputType
  }

  export type VisitLogGroupByOutputType = {
    id: string
    visitId: string
    userId: string
    action: string
    metadata: JsonValue | null
    timestamp: Date
    _count: VisitLogCountAggregateOutputType | null
    _min: VisitLogMinAggregateOutputType | null
    _max: VisitLogMaxAggregateOutputType | null
  }

  type GetVisitLogGroupByPayload<T extends VisitLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitLogGroupByOutputType[P]>
            : GetScalarType<T[P], VisitLogGroupByOutputType[P]>
        }
      >
    >


  export type VisitLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    userId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitLog"]>

  export type VisitLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    userId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitLog"]>

  export type VisitLogSelectScalar = {
    id?: boolean
    visitId?: boolean
    userId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type VisitLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VisitLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VisitLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitLog"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      userId: string
      action: string
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["visitLog"]>
    composites: {}
  }

  type VisitLogGetPayload<S extends boolean | null | undefined | VisitLogDefaultArgs> = $Result.GetResult<Prisma.$VisitLogPayload, S>

  type VisitLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitLogCountAggregateInputType | true
    }

  export interface VisitLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitLog'], meta: { name: 'VisitLog' } }
    /**
     * Find zero or one VisitLog that matches the filter.
     * @param {VisitLogFindUniqueArgs} args - Arguments to find a VisitLog
     * @example
     * // Get one VisitLog
     * const visitLog = await prisma.visitLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitLogFindUniqueArgs>(args: SelectSubset<T, VisitLogFindUniqueArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitLogFindUniqueOrThrowArgs} args - Arguments to find a VisitLog
     * @example
     * // Get one VisitLog
     * const visitLog = await prisma.visitLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitLogFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogFindFirstArgs} args - Arguments to find a VisitLog
     * @example
     * // Get one VisitLog
     * const visitLog = await prisma.visitLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitLogFindFirstArgs>(args?: SelectSubset<T, VisitLogFindFirstArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogFindFirstOrThrowArgs} args - Arguments to find a VisitLog
     * @example
     * // Get one VisitLog
     * const visitLog = await prisma.visitLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitLogFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitLogs
     * const visitLogs = await prisma.visitLog.findMany()
     * 
     * // Get first 10 VisitLogs
     * const visitLogs = await prisma.visitLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitLogWithIdOnly = await prisma.visitLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitLogFindManyArgs>(args?: SelectSubset<T, VisitLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitLog.
     * @param {VisitLogCreateArgs} args - Arguments to create a VisitLog.
     * @example
     * // Create one VisitLog
     * const VisitLog = await prisma.visitLog.create({
     *   data: {
     *     // ... data to create a VisitLog
     *   }
     * })
     * 
     */
    create<T extends VisitLogCreateArgs>(args: SelectSubset<T, VisitLogCreateArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitLogs.
     * @param {VisitLogCreateManyArgs} args - Arguments to create many VisitLogs.
     * @example
     * // Create many VisitLogs
     * const visitLog = await prisma.visitLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitLogCreateManyArgs>(args?: SelectSubset<T, VisitLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitLogs and returns the data saved in the database.
     * @param {VisitLogCreateManyAndReturnArgs} args - Arguments to create many VisitLogs.
     * @example
     * // Create many VisitLogs
     * const visitLog = await prisma.visitLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitLogs and only return the `id`
     * const visitLogWithIdOnly = await prisma.visitLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitLogCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitLog.
     * @param {VisitLogDeleteArgs} args - Arguments to delete one VisitLog.
     * @example
     * // Delete one VisitLog
     * const VisitLog = await prisma.visitLog.delete({
     *   where: {
     *     // ... filter to delete one VisitLog
     *   }
     * })
     * 
     */
    delete<T extends VisitLogDeleteArgs>(args: SelectSubset<T, VisitLogDeleteArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitLog.
     * @param {VisitLogUpdateArgs} args - Arguments to update one VisitLog.
     * @example
     * // Update one VisitLog
     * const visitLog = await prisma.visitLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitLogUpdateArgs>(args: SelectSubset<T, VisitLogUpdateArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitLogs.
     * @param {VisitLogDeleteManyArgs} args - Arguments to filter VisitLogs to delete.
     * @example
     * // Delete a few VisitLogs
     * const { count } = await prisma.visitLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitLogDeleteManyArgs>(args?: SelectSubset<T, VisitLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitLogs
     * const visitLog = await prisma.visitLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitLogUpdateManyArgs>(args: SelectSubset<T, VisitLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitLog.
     * @param {VisitLogUpsertArgs} args - Arguments to update or create a VisitLog.
     * @example
     * // Update or create a VisitLog
     * const visitLog = await prisma.visitLog.upsert({
     *   create: {
     *     // ... data to create a VisitLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitLog we want to update
     *   }
     * })
     */
    upsert<T extends VisitLogUpsertArgs>(args: SelectSubset<T, VisitLogUpsertArgs<ExtArgs>>): Prisma__VisitLogClient<$Result.GetResult<Prisma.$VisitLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogCountArgs} args - Arguments to filter VisitLogs to count.
     * @example
     * // Count the number of VisitLogs
     * const count = await prisma.visitLog.count({
     *   where: {
     *     // ... the filter for the VisitLogs we want to count
     *   }
     * })
    **/
    count<T extends VisitLogCountArgs>(
      args?: Subset<T, VisitLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitLogAggregateArgs>(args: Subset<T, VisitLogAggregateArgs>): Prisma.PrismaPromise<GetVisitLogAggregateType<T>>

    /**
     * Group by VisitLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitLogGroupByArgs['orderBy'] }
        : { orderBy?: VisitLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitLog model
   */
  readonly fields: VisitLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitLog model
   */ 
  interface VisitLogFieldRefs {
    readonly id: FieldRef<"VisitLog", 'String'>
    readonly visitId: FieldRef<"VisitLog", 'String'>
    readonly userId: FieldRef<"VisitLog", 'String'>
    readonly action: FieldRef<"VisitLog", 'String'>
    readonly metadata: FieldRef<"VisitLog", 'Json'>
    readonly timestamp: FieldRef<"VisitLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitLog findUnique
   */
  export type VisitLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitLog to fetch.
     */
    where: VisitLogWhereUniqueInput
  }

  /**
   * VisitLog findUniqueOrThrow
   */
  export type VisitLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitLog to fetch.
     */
    where: VisitLogWhereUniqueInput
  }

  /**
   * VisitLog findFirst
   */
  export type VisitLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitLog to fetch.
     */
    where?: VisitLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitLogs to fetch.
     */
    orderBy?: VisitLogOrderByWithRelationInput | VisitLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitLogs.
     */
    cursor?: VisitLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitLogs.
     */
    distinct?: VisitLogScalarFieldEnum | VisitLogScalarFieldEnum[]
  }

  /**
   * VisitLog findFirstOrThrow
   */
  export type VisitLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitLog to fetch.
     */
    where?: VisitLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitLogs to fetch.
     */
    orderBy?: VisitLogOrderByWithRelationInput | VisitLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitLogs.
     */
    cursor?: VisitLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitLogs.
     */
    distinct?: VisitLogScalarFieldEnum | VisitLogScalarFieldEnum[]
  }

  /**
   * VisitLog findMany
   */
  export type VisitLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitLogs to fetch.
     */
    where?: VisitLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitLogs to fetch.
     */
    orderBy?: VisitLogOrderByWithRelationInput | VisitLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitLogs.
     */
    cursor?: VisitLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitLogs.
     */
    skip?: number
    distinct?: VisitLogScalarFieldEnum | VisitLogScalarFieldEnum[]
  }

  /**
   * VisitLog create
   */
  export type VisitLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitLog.
     */
    data: XOR<VisitLogCreateInput, VisitLogUncheckedCreateInput>
  }

  /**
   * VisitLog createMany
   */
  export type VisitLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitLogs.
     */
    data: VisitLogCreateManyInput | VisitLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitLog createManyAndReturn
   */
  export type VisitLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitLogs.
     */
    data: VisitLogCreateManyInput | VisitLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitLog update
   */
  export type VisitLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitLog.
     */
    data: XOR<VisitLogUpdateInput, VisitLogUncheckedUpdateInput>
    /**
     * Choose, which VisitLog to update.
     */
    where: VisitLogWhereUniqueInput
  }

  /**
   * VisitLog updateMany
   */
  export type VisitLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitLogs.
     */
    data: XOR<VisitLogUpdateManyMutationInput, VisitLogUncheckedUpdateManyInput>
    /**
     * Filter which VisitLogs to update
     */
    where?: VisitLogWhereInput
  }

  /**
   * VisitLog upsert
   */
  export type VisitLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitLog to update in case it exists.
     */
    where: VisitLogWhereUniqueInput
    /**
     * In case the VisitLog found by the `where` argument doesn't exist, create a new VisitLog with this data.
     */
    create: XOR<VisitLogCreateInput, VisitLogUncheckedCreateInput>
    /**
     * In case the VisitLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitLogUpdateInput, VisitLogUncheckedUpdateInput>
  }

  /**
   * VisitLog delete
   */
  export type VisitLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
    /**
     * Filter which VisitLog to delete.
     */
    where: VisitLogWhereUniqueInput
  }

  /**
   * VisitLog deleteMany
   */
  export type VisitLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitLogs to delete
     */
    where?: VisitLogWhereInput
  }

  /**
   * VisitLog without action
   */
  export type VisitLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitLog
     */
    select?: VisitLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const MunicipalityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    regionId: 'regionId'
  };

  export type MunicipalityScalarFieldEnum = (typeof MunicipalityScalarFieldEnum)[keyof typeof MunicipalityScalarFieldEnum]


  export const VeredaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    municipalityId: 'municipalityId'
  };

  export type VeredaScalarFieldEnum = (typeof VeredaScalarFieldEnum)[keyof typeof VeredaScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    dni: 'dni',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    permissions: 'permissions',
    regionId: 'regionId',
    municipalityId: 'municipalityId',
    createdAt: 'createdAt',
    lastLogin: 'lastLogin',
    acceptedTerms: 'acceptedTerms',
    acceptedAt: 'acceptedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    url: 'url',
    version: 'version',
    hash: 'hash',
    uploaderId: 'uploaderId',
    regionId: 'regionId',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentCommentScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type DocumentCommentScalarFieldEnum = (typeof DocumentCommentScalarFieldEnum)[keyof typeof DocumentCommentScalarFieldEnum]


  export const RegionalReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    regionId: 'regionId',
    municipalityId: 'municipalityId',
    category: 'category',
    priority: 'priority',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type RegionalReportScalarFieldEnum = (typeof RegionalReportScalarFieldEnum)[keyof typeof RegionalReportScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    priority: 'priority',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    code: 'code',
    type: 'type',
    format: 'format',
    url: 'url',
    hashSha256: 'hashSha256',
    generatedById: 'generatedById',
    authorizedById: 'authorizedById',
    regionId: 'regionId',
    municipalityId: 'municipalityId',
    metadata: 'metadata',
    generatedAt: 'generatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReportDeliveryScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    recipient: 'recipient',
    channel: 'channel',
    status: 'status',
    sentAt: 'sentAt'
  };

  export type ReportDeliveryScalarFieldEnum = (typeof ReportDeliveryScalarFieldEnum)[keyof typeof ReportDeliveryScalarFieldEnum]


  export const NewsReadReceiptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    reportId: 'reportId',
    readAt: 'readAt'
  };

  export type NewsReadReceiptScalarFieldEnum = (typeof NewsReadReceiptScalarFieldEnum)[keyof typeof NewsReadReceiptScalarFieldEnum]


  export const VisitScalarFieldEnum: {
    id: 'id',
    source: 'source',
    reliability: 'reliability',
    citizenId: 'citizenId',
    fullName: 'fullName',
    addressText: 'addressText',
    phone: 'phone',
    latitude: 'latitude',
    longitude: 'longitude',
    gpsAccuracy: 'gpsAccuracy',
    verifiedAt: 'verifiedAt',
    status: 'status',
    priority: 'priority',
    regionId: 'regionId',
    municipalityId: 'municipalityId',
    vereda: 'vereda',
    assignedToId: 'assignedToId',
    assignedById: 'assignedById',
    assignedAt: 'assignedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitScalarFieldEnum = (typeof VisitScalarFieldEnum)[keyof typeof VisitScalarFieldEnum]


  export const VisitLogScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    userId: 'userId',
    action: 'action',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type VisitLogScalarFieldEnum = (typeof VisitLogScalarFieldEnum)[keyof typeof VisitLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'NewsCategory'
   */
  export type EnumNewsCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NewsCategory'>
    


  /**
   * Reference to a field of type 'NewsCategory[]'
   */
  export type ListEnumNewsCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NewsCategory[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReportFormat'
   */
  export type EnumReportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFormat'>
    


  /**
   * Reference to a field of type 'ReportFormat[]'
   */
  export type ListEnumReportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFormat[]'>
    


  /**
   * Reference to a field of type 'DeliveryChannel'
   */
  export type EnumDeliveryChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryChannel'>
    


  /**
   * Reference to a field of type 'DeliveryChannel[]'
   */
  export type ListEnumDeliveryChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryChannel[]'>
    


  /**
   * Reference to a field of type 'VisitSource'
   */
  export type EnumVisitSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitSource'>
    


  /**
   * Reference to a field of type 'VisitSource[]'
   */
  export type ListEnumVisitSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitSource[]'>
    


  /**
   * Reference to a field of type 'VisitReliability'
   */
  export type EnumVisitReliabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitReliability'>
    


  /**
   * Reference to a field of type 'VisitReliability[]'
   */
  export type ListEnumVisitReliabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitReliability[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VisitStatus'
   */
  export type EnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus'>
    


  /**
   * Reference to a field of type 'VisitStatus[]'
   */
  export type ListEnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: StringFilter<"Region"> | string
    name?: StringFilter<"Region"> | string
    code?: StringFilter<"Region"> | string
    users?: UserListRelationFilter
    reports?: RegionalReportListRelationFilter
    generatedReports?: ReportListRelationFilter
    visits?: VisitListRelationFilter
    documents?: DocumentListRelationFilter
    assignedUsers?: UserListRelationFilter
    municipalities?: MunicipalityListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    users?: UserOrderByRelationAggregateInput
    reports?: RegionalReportOrderByRelationAggregateInput
    generatedReports?: ReportOrderByRelationAggregateInput
    visits?: VisitOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    assignedUsers?: UserOrderByRelationAggregateInput
    municipalities?: MunicipalityOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    users?: UserListRelationFilter
    reports?: RegionalReportListRelationFilter
    generatedReports?: ReportListRelationFilter
    visits?: VisitListRelationFilter
    documents?: DocumentListRelationFilter
    assignedUsers?: UserListRelationFilter
    municipalities?: MunicipalityListRelationFilter
  }, "id" | "name" | "code">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Region"> | string
    name?: StringWithAggregatesFilter<"Region"> | string
    code?: StringWithAggregatesFilter<"Region"> | string
  }

  export type MunicipalityWhereInput = {
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    id?: StringFilter<"Municipality"> | string
    name?: StringFilter<"Municipality"> | string
    regionId?: StringFilter<"Municipality"> | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    users?: UserListRelationFilter
    assignedUsers?: UserListRelationFilter
    reports?: RegionalReportListRelationFilter
    generatedReports?: ReportListRelationFilter
    visits?: VisitListRelationFilter
    veredas?: VeredaListRelationFilter
  }

  export type MunicipalityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
    region?: RegionOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    assignedUsers?: UserOrderByRelationAggregateInput
    reports?: RegionalReportOrderByRelationAggregateInput
    generatedReports?: ReportOrderByRelationAggregateInput
    visits?: VisitOrderByRelationAggregateInput
    veredas?: VeredaOrderByRelationAggregateInput
  }

  export type MunicipalityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    regionId_name?: MunicipalityRegionIdNameCompoundUniqueInput
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    name?: StringFilter<"Municipality"> | string
    regionId?: StringFilter<"Municipality"> | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    users?: UserListRelationFilter
    assignedUsers?: UserListRelationFilter
    reports?: RegionalReportListRelationFilter
    generatedReports?: ReportListRelationFilter
    visits?: VisitListRelationFilter
    veredas?: VeredaListRelationFilter
  }, "id" | "regionId_name">

  export type MunicipalityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
    _count?: MunicipalityCountOrderByAggregateInput
    _max?: MunicipalityMaxOrderByAggregateInput
    _min?: MunicipalityMinOrderByAggregateInput
  }

  export type MunicipalityScalarWhereWithAggregatesInput = {
    AND?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    OR?: MunicipalityScalarWhereWithAggregatesInput[]
    NOT?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Municipality"> | string
    name?: StringWithAggregatesFilter<"Municipality"> | string
    regionId?: StringWithAggregatesFilter<"Municipality"> | string
  }

  export type VeredaWhereInput = {
    AND?: VeredaWhereInput | VeredaWhereInput[]
    OR?: VeredaWhereInput[]
    NOT?: VeredaWhereInput | VeredaWhereInput[]
    id?: StringFilter<"Vereda"> | string
    name?: StringFilter<"Vereda"> | string
    municipalityId?: StringFilter<"Vereda"> | string
    municipality?: XOR<MunicipalityRelationFilter, MunicipalityWhereInput>
    assignedUsers?: UserListRelationFilter
  }

  export type VeredaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    municipality?: MunicipalityOrderByWithRelationInput
    assignedUsers?: UserOrderByRelationAggregateInput
  }

  export type VeredaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    municipalityId_name?: VeredaMunicipalityIdNameCompoundUniqueInput
    AND?: VeredaWhereInput | VeredaWhereInput[]
    OR?: VeredaWhereInput[]
    NOT?: VeredaWhereInput | VeredaWhereInput[]
    name?: StringFilter<"Vereda"> | string
    municipalityId?: StringFilter<"Vereda"> | string
    municipality?: XOR<MunicipalityRelationFilter, MunicipalityWhereInput>
    assignedUsers?: UserListRelationFilter
  }, "id" | "municipalityId_name">

  export type VeredaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    _count?: VeredaCountOrderByAggregateInput
    _max?: VeredaMaxOrderByAggregateInput
    _min?: VeredaMinOrderByAggregateInput
  }

  export type VeredaScalarWhereWithAggregatesInput = {
    AND?: VeredaScalarWhereWithAggregatesInput | VeredaScalarWhereWithAggregatesInput[]
    OR?: VeredaScalarWhereWithAggregatesInput[]
    NOT?: VeredaScalarWhereWithAggregatesInput | VeredaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vereda"> | string
    name?: StringWithAggregatesFilter<"Vereda"> | string
    municipalityId?: StringWithAggregatesFilter<"Vereda"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    dni?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    permissions?: JsonFilter<"User">
    regionId?: StringNullableFilter<"User"> | string | null
    municipalityId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    acceptedTerms?: BoolFilter<"User"> | boolean
    acceptedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    assignedRegions?: RegionListRelationFilter
    assignedMunicipalities?: MunicipalityListRelationFilter
    assignedVeredas?: VeredaListRelationFilter
    documents?: DocumentListRelationFilter
    comments?: DocumentCommentListRelationFilter
    news?: RegionalReportListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    reports?: ReportListRelationFilter
    authorizedReports?: ReportListRelationFilter
    readReceipts?: NewsReadReceiptListRelationFilter
    assignedVisits?: VisitListRelationFilter
    delegatedVisits?: VisitListRelationFilter
    visitLogs?: VisitLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    dni?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    regionId?: SortOrderInput | SortOrder
    municipalityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    acceptedTerms?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    region?: RegionOrderByWithRelationInput
    municipality?: MunicipalityOrderByWithRelationInput
    assignedRegions?: RegionOrderByRelationAggregateInput
    assignedMunicipalities?: MunicipalityOrderByRelationAggregateInput
    assignedVeredas?: VeredaOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    comments?: DocumentCommentOrderByRelationAggregateInput
    news?: RegionalReportOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    authorizedReports?: ReportOrderByRelationAggregateInput
    readReceipts?: NewsReadReceiptOrderByRelationAggregateInput
    assignedVisits?: VisitOrderByRelationAggregateInput
    delegatedVisits?: VisitOrderByRelationAggregateInput
    visitLogs?: VisitLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    dni?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    permissions?: JsonFilter<"User">
    regionId?: StringNullableFilter<"User"> | string | null
    municipalityId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    acceptedTerms?: BoolFilter<"User"> | boolean
    acceptedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    assignedRegions?: RegionListRelationFilter
    assignedMunicipalities?: MunicipalityListRelationFilter
    assignedVeredas?: VeredaListRelationFilter
    documents?: DocumentListRelationFilter
    comments?: DocumentCommentListRelationFilter
    news?: RegionalReportListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    reports?: ReportListRelationFilter
    authorizedReports?: ReportListRelationFilter
    readReceipts?: NewsReadReceiptListRelationFilter
    assignedVisits?: VisitListRelationFilter
    delegatedVisits?: VisitListRelationFilter
    visitLogs?: VisitLogListRelationFilter
  }, "id" | "email" | "dni">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    dni?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    regionId?: SortOrderInput | SortOrder
    municipalityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    acceptedTerms?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    dni?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    permissions?: JsonWithAggregatesFilter<"User">
    regionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    municipalityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    acceptedTerms?: BoolWithAggregatesFilter<"User"> | boolean
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    version?: IntFilter<"Document"> | number
    hash?: StringNullableFilter<"Document"> | string | null
    uploaderId?: StringFilter<"Document"> | string
    regionId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    comments?: DocumentCommentListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    hash?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    regionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    uploader?: UserOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
    comments?: DocumentCommentOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    version?: IntFilter<"Document"> | number
    hash?: StringNullableFilter<"Document"> | string | null
    uploaderId?: StringFilter<"Document"> | string
    regionId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    comments?: DocumentCommentListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    hash?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    regionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    version?: IntWithAggregatesFilter<"Document"> | number
    hash?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploaderId?: StringWithAggregatesFilter<"Document"> | string
    regionId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentCommentWhereInput = {
    AND?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    OR?: DocumentCommentWhereInput[]
    NOT?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    id?: StringFilter<"DocumentComment"> | string
    documentId?: StringFilter<"DocumentComment"> | string
    userId?: StringFilter<"DocumentComment"> | string
    content?: StringFilter<"DocumentComment"> | string
    createdAt?: DateTimeFilter<"DocumentComment"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentCommentOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    OR?: DocumentCommentWhereInput[]
    NOT?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    documentId?: StringFilter<"DocumentComment"> | string
    userId?: StringFilter<"DocumentComment"> | string
    content?: StringFilter<"DocumentComment"> | string
    createdAt?: DateTimeFilter<"DocumentComment"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentCommentOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentCommentCountOrderByAggregateInput
    _max?: DocumentCommentMaxOrderByAggregateInput
    _min?: DocumentCommentMinOrderByAggregateInput
  }

  export type DocumentCommentScalarWhereWithAggregatesInput = {
    AND?: DocumentCommentScalarWhereWithAggregatesInput | DocumentCommentScalarWhereWithAggregatesInput[]
    OR?: DocumentCommentScalarWhereWithAggregatesInput[]
    NOT?: DocumentCommentScalarWhereWithAggregatesInput | DocumentCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentComment"> | string
    documentId?: StringWithAggregatesFilter<"DocumentComment"> | string
    userId?: StringWithAggregatesFilter<"DocumentComment"> | string
    content?: StringWithAggregatesFilter<"DocumentComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentComment"> | Date | string
  }

  export type RegionalReportWhereInput = {
    AND?: RegionalReportWhereInput | RegionalReportWhereInput[]
    OR?: RegionalReportWhereInput[]
    NOT?: RegionalReportWhereInput | RegionalReportWhereInput[]
    id?: StringFilter<"RegionalReport"> | string
    userId?: StringFilter<"RegionalReport"> | string
    regionId?: StringNullableFilter<"RegionalReport"> | string | null
    municipalityId?: StringNullableFilter<"RegionalReport"> | string | null
    category?: EnumNewsCategoryFilter<"RegionalReport"> | $Enums.NewsCategory
    priority?: EnumPriorityFilter<"RegionalReport"> | $Enums.Priority
    title?: StringFilter<"RegionalReport"> | string
    content?: StringFilter<"RegionalReport"> | string
    createdAt?: DateTimeFilter<"RegionalReport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    alerts?: AlertListRelationFilter
    readReceipts?: NewsReadReceiptListRelationFilter
  }

  export type RegionalReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    regionId?: SortOrderInput | SortOrder
    municipalityId?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
    municipality?: MunicipalityOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
    readReceipts?: NewsReadReceiptOrderByRelationAggregateInput
  }

  export type RegionalReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RegionalReportWhereInput | RegionalReportWhereInput[]
    OR?: RegionalReportWhereInput[]
    NOT?: RegionalReportWhereInput | RegionalReportWhereInput[]
    userId?: StringFilter<"RegionalReport"> | string
    regionId?: StringNullableFilter<"RegionalReport"> | string | null
    municipalityId?: StringNullableFilter<"RegionalReport"> | string | null
    category?: EnumNewsCategoryFilter<"RegionalReport"> | $Enums.NewsCategory
    priority?: EnumPriorityFilter<"RegionalReport"> | $Enums.Priority
    title?: StringFilter<"RegionalReport"> | string
    content?: StringFilter<"RegionalReport"> | string
    createdAt?: DateTimeFilter<"RegionalReport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    alerts?: AlertListRelationFilter
    readReceipts?: NewsReadReceiptListRelationFilter
  }, "id">

  export type RegionalReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    regionId?: SortOrderInput | SortOrder
    municipalityId?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: RegionalReportCountOrderByAggregateInput
    _max?: RegionalReportMaxOrderByAggregateInput
    _min?: RegionalReportMinOrderByAggregateInput
  }

  export type RegionalReportScalarWhereWithAggregatesInput = {
    AND?: RegionalReportScalarWhereWithAggregatesInput | RegionalReportScalarWhereWithAggregatesInput[]
    OR?: RegionalReportScalarWhereWithAggregatesInput[]
    NOT?: RegionalReportScalarWhereWithAggregatesInput | RegionalReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RegionalReport"> | string
    userId?: StringWithAggregatesFilter<"RegionalReport"> | string
    regionId?: StringNullableWithAggregatesFilter<"RegionalReport"> | string | null
    municipalityId?: StringNullableWithAggregatesFilter<"RegionalReport"> | string | null
    category?: EnumNewsCategoryWithAggregatesFilter<"RegionalReport"> | $Enums.NewsCategory
    priority?: EnumPriorityWithAggregatesFilter<"RegionalReport"> | $Enums.Priority
    title?: StringWithAggregatesFilter<"RegionalReport"> | string
    content?: StringWithAggregatesFilter<"RegionalReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RegionalReport"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    reportId?: StringFilter<"Alert"> | string
    priority?: EnumPriorityFilter<"Alert"> | $Enums.Priority
    status?: StringFilter<"Alert"> | string
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    report?: XOR<RegionalReportRelationFilter, RegionalReportWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    report?: RegionalReportOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    reportId?: StringFilter<"Alert"> | string
    priority?: EnumPriorityFilter<"Alert"> | $Enums.Priority
    status?: StringFilter<"Alert"> | string
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    report?: XOR<RegionalReportRelationFilter, RegionalReportWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    reportId?: StringWithAggregatesFilter<"Alert"> | string
    priority?: EnumPriorityWithAggregatesFilter<"Alert"> | $Enums.Priority
    status?: StringWithAggregatesFilter<"Alert"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    code?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"Report"> | $Enums.ReportFormat
    url?: StringFilter<"Report"> | string
    hashSha256?: StringFilter<"Report"> | string
    generatedById?: StringFilter<"Report"> | string
    authorizedById?: StringNullableFilter<"Report"> | string | null
    regionId?: StringNullableFilter<"Report"> | string | null
    municipalityId?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    generatedBy?: XOR<UserRelationFilter, UserWhereInput>
    authorizedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    deliveries?: ReportDeliveryListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    format?: SortOrder
    url?: SortOrder
    hashSha256?: SortOrder
    generatedById?: SortOrder
    authorizedById?: SortOrderInput | SortOrder
    regionId?: SortOrderInput | SortOrder
    municipalityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: UserOrderByWithRelationInput
    authorizedBy?: UserOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
    municipality?: MunicipalityOrderByWithRelationInput
    deliveries?: ReportDeliveryOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"Report"> | $Enums.ReportFormat
    url?: StringFilter<"Report"> | string
    hashSha256?: StringFilter<"Report"> | string
    generatedById?: StringFilter<"Report"> | string
    authorizedById?: StringNullableFilter<"Report"> | string | null
    regionId?: StringNullableFilter<"Report"> | string | null
    municipalityId?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    generatedBy?: XOR<UserRelationFilter, UserWhereInput>
    authorizedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    deliveries?: ReportDeliveryListRelationFilter
  }, "id" | "code">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    format?: SortOrder
    url?: SortOrder
    hashSha256?: SortOrder
    generatedById?: SortOrder
    authorizedById?: SortOrderInput | SortOrder
    regionId?: SortOrderInput | SortOrder
    municipalityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    code?: StringWithAggregatesFilter<"Report"> | string
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatWithAggregatesFilter<"Report"> | $Enums.ReportFormat
    url?: StringWithAggregatesFilter<"Report"> | string
    hashSha256?: StringWithAggregatesFilter<"Report"> | string
    generatedById?: StringWithAggregatesFilter<"Report"> | string
    authorizedById?: StringNullableWithAggregatesFilter<"Report"> | string | null
    regionId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    municipalityId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Report">
    generatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type ReportDeliveryWhereInput = {
    AND?: ReportDeliveryWhereInput | ReportDeliveryWhereInput[]
    OR?: ReportDeliveryWhereInput[]
    NOT?: ReportDeliveryWhereInput | ReportDeliveryWhereInput[]
    id?: StringFilter<"ReportDelivery"> | string
    reportId?: StringFilter<"ReportDelivery"> | string
    recipient?: StringFilter<"ReportDelivery"> | string
    channel?: EnumDeliveryChannelFilter<"ReportDelivery"> | $Enums.DeliveryChannel
    status?: StringFilter<"ReportDelivery"> | string
    sentAt?: DateTimeFilter<"ReportDelivery"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }

  export type ReportDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    report?: ReportOrderByWithRelationInput
  }

  export type ReportDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportDeliveryWhereInput | ReportDeliveryWhereInput[]
    OR?: ReportDeliveryWhereInput[]
    NOT?: ReportDeliveryWhereInput | ReportDeliveryWhereInput[]
    reportId?: StringFilter<"ReportDelivery"> | string
    recipient?: StringFilter<"ReportDelivery"> | string
    channel?: EnumDeliveryChannelFilter<"ReportDelivery"> | $Enums.DeliveryChannel
    status?: StringFilter<"ReportDelivery"> | string
    sentAt?: DateTimeFilter<"ReportDelivery"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }, "id">

  export type ReportDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    _count?: ReportDeliveryCountOrderByAggregateInput
    _max?: ReportDeliveryMaxOrderByAggregateInput
    _min?: ReportDeliveryMinOrderByAggregateInput
  }

  export type ReportDeliveryScalarWhereWithAggregatesInput = {
    AND?: ReportDeliveryScalarWhereWithAggregatesInput | ReportDeliveryScalarWhereWithAggregatesInput[]
    OR?: ReportDeliveryScalarWhereWithAggregatesInput[]
    NOT?: ReportDeliveryScalarWhereWithAggregatesInput | ReportDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportDelivery"> | string
    reportId?: StringWithAggregatesFilter<"ReportDelivery"> | string
    recipient?: StringWithAggregatesFilter<"ReportDelivery"> | string
    channel?: EnumDeliveryChannelWithAggregatesFilter<"ReportDelivery"> | $Enums.DeliveryChannel
    status?: StringWithAggregatesFilter<"ReportDelivery"> | string
    sentAt?: DateTimeWithAggregatesFilter<"ReportDelivery"> | Date | string
  }

  export type NewsReadReceiptWhereInput = {
    AND?: NewsReadReceiptWhereInput | NewsReadReceiptWhereInput[]
    OR?: NewsReadReceiptWhereInput[]
    NOT?: NewsReadReceiptWhereInput | NewsReadReceiptWhereInput[]
    id?: StringFilter<"NewsReadReceipt"> | string
    userId?: StringFilter<"NewsReadReceipt"> | string
    reportId?: StringFilter<"NewsReadReceipt"> | string
    readAt?: DateTimeFilter<"NewsReadReceipt"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    report?: XOR<RegionalReportRelationFilter, RegionalReportWhereInput>
  }

  export type NewsReadReceiptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    readAt?: SortOrder
    user?: UserOrderByWithRelationInput
    report?: RegionalReportOrderByWithRelationInput
  }

  export type NewsReadReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_reportId?: NewsReadReceiptUserIdReportIdCompoundUniqueInput
    AND?: NewsReadReceiptWhereInput | NewsReadReceiptWhereInput[]
    OR?: NewsReadReceiptWhereInput[]
    NOT?: NewsReadReceiptWhereInput | NewsReadReceiptWhereInput[]
    userId?: StringFilter<"NewsReadReceipt"> | string
    reportId?: StringFilter<"NewsReadReceipt"> | string
    readAt?: DateTimeFilter<"NewsReadReceipt"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    report?: XOR<RegionalReportRelationFilter, RegionalReportWhereInput>
  }, "id" | "userId_reportId">

  export type NewsReadReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    readAt?: SortOrder
    _count?: NewsReadReceiptCountOrderByAggregateInput
    _max?: NewsReadReceiptMaxOrderByAggregateInput
    _min?: NewsReadReceiptMinOrderByAggregateInput
  }

  export type NewsReadReceiptScalarWhereWithAggregatesInput = {
    AND?: NewsReadReceiptScalarWhereWithAggregatesInput | NewsReadReceiptScalarWhereWithAggregatesInput[]
    OR?: NewsReadReceiptScalarWhereWithAggregatesInput[]
    NOT?: NewsReadReceiptScalarWhereWithAggregatesInput | NewsReadReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsReadReceipt"> | string
    userId?: StringWithAggregatesFilter<"NewsReadReceipt"> | string
    reportId?: StringWithAggregatesFilter<"NewsReadReceipt"> | string
    readAt?: DateTimeWithAggregatesFilter<"NewsReadReceipt"> | Date | string
  }

  export type VisitWhereInput = {
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    id?: StringFilter<"Visit"> | string
    source?: EnumVisitSourceFilter<"Visit"> | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFilter<"Visit"> | $Enums.VisitReliability
    citizenId?: StringNullableFilter<"Visit"> | string | null
    fullName?: StringNullableFilter<"Visit"> | string | null
    addressText?: StringFilter<"Visit"> | string
    phone?: StringNullableFilter<"Visit"> | string | null
    latitude?: FloatNullableFilter<"Visit"> | number | null
    longitude?: FloatNullableFilter<"Visit"> | number | null
    gpsAccuracy?: FloatNullableFilter<"Visit"> | number | null
    verifiedAt?: DateTimeNullableFilter<"Visit"> | Date | string | null
    status?: EnumVisitStatusFilter<"Visit"> | $Enums.VisitStatus
    priority?: EnumPriorityFilter<"Visit"> | $Enums.Priority
    regionId?: StringFilter<"Visit"> | string
    municipalityId?: StringNullableFilter<"Visit"> | string | null
    vereda?: StringNullableFilter<"Visit"> | string | null
    assignedToId?: StringNullableFilter<"Visit"> | string | null
    assignedById?: StringNullableFilter<"Visit"> | string | null
    assignedAt?: DateTimeNullableFilter<"Visit"> | Date | string | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    logs?: VisitLogListRelationFilter
  }

  export type VisitOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    reliability?: SortOrder
    citizenId?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    addressText?: SortOrder
    phone?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    gpsAccuracy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrderInput | SortOrder
    vereda?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedById?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    region?: RegionOrderByWithRelationInput
    municipality?: MunicipalityOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
    logs?: VisitLogOrderByRelationAggregateInput
  }

  export type VisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    source?: EnumVisitSourceFilter<"Visit"> | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFilter<"Visit"> | $Enums.VisitReliability
    citizenId?: StringNullableFilter<"Visit"> | string | null
    fullName?: StringNullableFilter<"Visit"> | string | null
    addressText?: StringFilter<"Visit"> | string
    phone?: StringNullableFilter<"Visit"> | string | null
    latitude?: FloatNullableFilter<"Visit"> | number | null
    longitude?: FloatNullableFilter<"Visit"> | number | null
    gpsAccuracy?: FloatNullableFilter<"Visit"> | number | null
    verifiedAt?: DateTimeNullableFilter<"Visit"> | Date | string | null
    status?: EnumVisitStatusFilter<"Visit"> | $Enums.VisitStatus
    priority?: EnumPriorityFilter<"Visit"> | $Enums.Priority
    regionId?: StringFilter<"Visit"> | string
    municipalityId?: StringNullableFilter<"Visit"> | string | null
    vereda?: StringNullableFilter<"Visit"> | string | null
    assignedToId?: StringNullableFilter<"Visit"> | string | null
    assignedById?: StringNullableFilter<"Visit"> | string | null
    assignedAt?: DateTimeNullableFilter<"Visit"> | Date | string | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    municipality?: XOR<MunicipalityNullableRelationFilter, MunicipalityWhereInput> | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    logs?: VisitLogListRelationFilter
  }, "id">

  export type VisitOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    reliability?: SortOrder
    citizenId?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    addressText?: SortOrder
    phone?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    gpsAccuracy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrderInput | SortOrder
    vereda?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedById?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitCountOrderByAggregateInput
    _avg?: VisitAvgOrderByAggregateInput
    _max?: VisitMaxOrderByAggregateInput
    _min?: VisitMinOrderByAggregateInput
    _sum?: VisitSumOrderByAggregateInput
  }

  export type VisitScalarWhereWithAggregatesInput = {
    AND?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    OR?: VisitScalarWhereWithAggregatesInput[]
    NOT?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Visit"> | string
    source?: EnumVisitSourceWithAggregatesFilter<"Visit"> | $Enums.VisitSource
    reliability?: EnumVisitReliabilityWithAggregatesFilter<"Visit"> | $Enums.VisitReliability
    citizenId?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    addressText?: StringWithAggregatesFilter<"Visit"> | string
    phone?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Visit"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Visit"> | number | null
    gpsAccuracy?: FloatNullableWithAggregatesFilter<"Visit"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Visit"> | Date | string | null
    status?: EnumVisitStatusWithAggregatesFilter<"Visit"> | $Enums.VisitStatus
    priority?: EnumPriorityWithAggregatesFilter<"Visit"> | $Enums.Priority
    regionId?: StringWithAggregatesFilter<"Visit"> | string
    municipalityId?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    vereda?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    assignedToId?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    assignedById?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Visit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
  }

  export type VisitLogWhereInput = {
    AND?: VisitLogWhereInput | VisitLogWhereInput[]
    OR?: VisitLogWhereInput[]
    NOT?: VisitLogWhereInput | VisitLogWhereInput[]
    id?: StringFilter<"VisitLog"> | string
    visitId?: StringFilter<"VisitLog"> | string
    userId?: StringFilter<"VisitLog"> | string
    action?: StringFilter<"VisitLog"> | string
    metadata?: JsonNullableFilter<"VisitLog">
    timestamp?: DateTimeFilter<"VisitLog"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VisitLogOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    visit?: VisitOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type VisitLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitLogWhereInput | VisitLogWhereInput[]
    OR?: VisitLogWhereInput[]
    NOT?: VisitLogWhereInput | VisitLogWhereInput[]
    visitId?: StringFilter<"VisitLog"> | string
    userId?: StringFilter<"VisitLog"> | string
    action?: StringFilter<"VisitLog"> | string
    metadata?: JsonNullableFilter<"VisitLog">
    timestamp?: DateTimeFilter<"VisitLog"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VisitLogOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: VisitLogCountOrderByAggregateInput
    _max?: VisitLogMaxOrderByAggregateInput
    _min?: VisitLogMinOrderByAggregateInput
  }

  export type VisitLogScalarWhereWithAggregatesInput = {
    AND?: VisitLogScalarWhereWithAggregatesInput | VisitLogScalarWhereWithAggregatesInput[]
    OR?: VisitLogScalarWhereWithAggregatesInput[]
    NOT?: VisitLogScalarWhereWithAggregatesInput | VisitLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitLog"> | string
    visitId?: StringWithAggregatesFilter<"VisitLog"> | string
    userId?: StringWithAggregatesFilter<"VisitLog"> | string
    action?: StringWithAggregatesFilter<"VisitLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"VisitLog">
    timestamp?: DateTimeWithAggregatesFilter<"VisitLog"> | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ipAddress?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    ipAddress?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    ipAddress?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: string
    name: string
    code: string
  }

  export type RegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityCreateInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    users?: UserCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateInput = {
    id?: string
    name: string
    regionId: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityCreateManyInput = {
    id?: string
    name: string
    regionId: string
  }

  export type MunicipalityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type VeredaCreateInput = {
    id?: string
    name: string
    municipality: MunicipalityCreateNestedOneWithoutVeredasInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedVeredasInput
  }

  export type VeredaUncheckedCreateInput = {
    id?: string
    name: string
    municipalityId: string
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedVeredasInput
  }

  export type VeredaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipality?: MunicipalityUpdateOneRequiredWithoutVeredasNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedVeredasNestedInput
  }

  export type VeredaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: StringFieldUpdateOperationsInput | string
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedVeredasNestedInput
  }

  export type VeredaCreateManyInput = {
    id?: string
    name: string
    municipalityId: string
  }

  export type VeredaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VeredaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutDocumentsInput
    region?: RegionCreateNestedOneWithoutDocumentsInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    uploaderId: string
    regionId?: string | null
    createdAt?: Date | string
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    region?: RegionUpdateOneWithoutDocumentsNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    uploaderId: string
    regionId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type DocumentCommentUncheckedCreateInput = {
    id?: string
    documentId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type DocumentCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type DocumentCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentCreateManyInput = {
    id?: string
    documentId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type DocumentCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionalReportCreateInput = {
    id?: string
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNewsInput
    region?: RegionCreateNestedOneWithoutReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutReportsInput
    alerts?: AlertCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUncheckedCreateInput = {
    id?: string
    userId: string
    regionId?: string | null
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNewsNestedInput
    region?: RegionUpdateOneWithoutReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutReportsNestedInput
    alerts?: AlertUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportCreateManyInput = {
    id?: string
    userId: string
    regionId?: string | null
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
  }

  export type RegionalReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionalReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    priority: $Enums.Priority
    status?: string
    createdAt?: Date | string
    report: RegionalReportCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    reportId: string
    priority: $Enums.Priority
    status?: string
    createdAt?: Date | string
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: RegionalReportUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyInput = {
    id?: string
    reportId: string
    priority: $Enums.Priority
    status?: string
    createdAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy: UserCreateNestedOneWithoutReportsInput
    authorizedBy?: UserCreateNestedOneWithoutAuthorizedReportsInput
    region?: RegionCreateNestedOneWithoutGeneratedReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutGeneratedReportsInput
    deliveries?: ReportDeliveryCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    deliveries?: ReportDeliveryUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    authorizedBy?: UserUpdateOneWithoutAuthorizedReportsNestedInput
    region?: RegionUpdateOneWithoutGeneratedReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutGeneratedReportsNestedInput
    deliveries?: ReportDeliveryUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: ReportDeliveryUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDeliveryCreateInput = {
    id?: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt?: Date | string
    report: ReportCreateNestedOneWithoutDeliveriesInput
  }

  export type ReportDeliveryUncheckedCreateInput = {
    id?: string
    reportId: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt?: Date | string
  }

  export type ReportDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type ReportDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDeliveryCreateManyInput = {
    id?: string
    reportId: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt?: Date | string
  }

  export type ReportDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptCreateInput = {
    id?: string
    readAt?: Date | string
    user: UserCreateNestedOneWithoutReadReceiptsInput
    report: RegionalReportCreateNestedOneWithoutReadReceiptsInput
  }

  export type NewsReadReceiptUncheckedCreateInput = {
    id?: string
    userId: string
    reportId: string
    readAt?: Date | string
  }

  export type NewsReadReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadReceiptsNestedInput
    report?: RegionalReportUpdateOneRequiredWithoutReadReceiptsNestedInput
  }

  export type NewsReadReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptCreateManyInput = {
    id?: string
    userId: string
    reportId: string
    readAt?: Date | string
  }

  export type NewsReadReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    vereda?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    region: RegionCreateNestedOneWithoutVisitsInput
    municipality?: MunicipalityCreateNestedOneWithoutVisitsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedVisitsInput
    assignedBy?: UserCreateNestedOneWithoutDelegatedVisitsInput
    logs?: VisitLogCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: VisitLogUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutVisitsNestedInput
    municipality?: MunicipalityUpdateOneWithoutVisitsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedVisitsNestedInput
    assignedBy?: UserUpdateOneWithoutDelegatedVisitsNestedInput
    logs?: VisitLogUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: VisitLogUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitCreateManyInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogCreateInput = {
    id?: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    visit: VisitCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutVisitLogsInput
  }

  export type VisitLogUncheckedCreateInput = {
    id?: string
    visitId: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type VisitLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutVisitLogsNestedInput
  }

  export type VisitLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogCreateManyInput = {
    id?: string
    visitId: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type VisitLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RegionalReportListRelationFilter = {
    every?: RegionalReportWhereInput
    some?: RegionalReportWhereInput
    none?: RegionalReportWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type VisitListRelationFilter = {
    every?: VisitWhereInput
    some?: VisitWhereInput
    none?: VisitWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type MunicipalityListRelationFilter = {
    every?: MunicipalityWhereInput
    some?: MunicipalityWhereInput
    none?: MunicipalityWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionalReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type VeredaListRelationFilter = {
    every?: VeredaWhereInput
    some?: VeredaWhereInput
    none?: VeredaWhereInput
  }

  export type VeredaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipalityRegionIdNameCompoundUniqueInput = {
    regionId: string
    name: string
  }

  export type MunicipalityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
  }

  export type MunicipalityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
  }

  export type MunicipalityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
  }

  export type MunicipalityRelationFilter = {
    is?: MunicipalityWhereInput
    isNot?: MunicipalityWhereInput
  }

  export type VeredaMunicipalityIdNameCompoundUniqueInput = {
    municipalityId: string
    name: string
  }

  export type VeredaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
  }

  export type VeredaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
  }

  export type VeredaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RegionNullableRelationFilter = {
    is?: RegionWhereInput | null
    isNot?: RegionWhereInput | null
  }

  export type MunicipalityNullableRelationFilter = {
    is?: MunicipalityWhereInput | null
    isNot?: MunicipalityWhereInput | null
  }

  export type RegionListRelationFilter = {
    every?: RegionWhereInput
    some?: RegionWhereInput
    none?: RegionWhereInput
  }

  export type DocumentCommentListRelationFilter = {
    every?: DocumentCommentWhereInput
    some?: DocumentCommentWhereInput
    none?: DocumentCommentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NewsReadReceiptListRelationFilter = {
    every?: NewsReadReceiptWhereInput
    some?: NewsReadReceiptWhereInput
    none?: NewsReadReceiptWhereInput
  }

  export type VisitLogListRelationFilter = {
    every?: VisitLogWhereInput
    some?: VisitLogWhereInput
    none?: VisitLogWhereInput
  }

  export type RegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsReadReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    dni?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
    acceptedTerms?: SortOrder
    acceptedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    dni?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
    acceptedTerms?: SortOrder
    acceptedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    dni?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
    acceptedTerms?: SortOrder
    acceptedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    uploaderId?: SortOrder
    regionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    uploaderId?: SortOrder
    regionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    uploaderId?: SortOrder
    regionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentCommentCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentCommentMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNewsCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsCategory | EnumNewsCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsCategoryFilter<$PrismaModel> | $Enums.NewsCategory
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionalReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RegionalReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RegionalReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNewsCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsCategory | EnumNewsCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NewsCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNewsCategoryFilter<$PrismaModel>
    _max?: NestedEnumNewsCategoryFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type RegionalReportRelationFilter = {
    is?: RegionalReportWhereInput
    isNot?: RegionalReportWhereInput
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatFilter<$PrismaModel> | $Enums.ReportFormat
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReportDeliveryListRelationFilter = {
    every?: ReportDeliveryWhereInput
    some?: ReportDeliveryWhereInput
    none?: ReportDeliveryWhereInput
  }

  export type ReportDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    format?: SortOrder
    url?: SortOrder
    hashSha256?: SortOrder
    generatedById?: SortOrder
    authorizedById?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    metadata?: SortOrder
    generatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    format?: SortOrder
    url?: SortOrder
    hashSha256?: SortOrder
    generatedById?: SortOrder
    authorizedById?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    generatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    format?: SortOrder
    url?: SortOrder
    hashSha256?: SortOrder
    generatedById?: SortOrder
    authorizedById?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    generatedAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ReportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFormatFilter<$PrismaModel>
    _max?: NestedEnumReportFormatFilter<$PrismaModel>
  }

  export type EnumDeliveryChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryChannel | EnumDeliveryChannelFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryChannelFilter<$PrismaModel> | $Enums.DeliveryChannel
  }

  export type ReportRelationFilter = {
    is?: ReportWhereInput
    isNot?: ReportWhereInput
  }

  export type ReportDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
  }

  export type ReportDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
  }

  export type ReportDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
  }

  export type EnumDeliveryChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryChannel | EnumDeliveryChannelFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryChannelWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryChannelFilter<$PrismaModel>
    _max?: NestedEnumDeliveryChannelFilter<$PrismaModel>
  }

  export type NewsReadReceiptUserIdReportIdCompoundUniqueInput = {
    userId: string
    reportId: string
  }

  export type NewsReadReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    readAt?: SortOrder
  }

  export type NewsReadReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    readAt?: SortOrder
  }

  export type NewsReadReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    readAt?: SortOrder
  }

  export type EnumVisitSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitSource | EnumVisitSourceFieldRefInput<$PrismaModel>
    in?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitSourceFilter<$PrismaModel> | $Enums.VisitSource
  }

  export type EnumVisitReliabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitReliability | EnumVisitReliabilityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitReliabilityFilter<$PrismaModel> | $Enums.VisitReliability
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type VisitCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    reliability?: SortOrder
    citizenId?: SortOrder
    fullName?: SortOrder
    addressText?: SortOrder
    phone?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gpsAccuracy?: SortOrder
    verifiedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    vereda?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    gpsAccuracy?: SortOrder
  }

  export type VisitMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    reliability?: SortOrder
    citizenId?: SortOrder
    fullName?: SortOrder
    addressText?: SortOrder
    phone?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gpsAccuracy?: SortOrder
    verifiedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    vereda?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    reliability?: SortOrder
    citizenId?: SortOrder
    fullName?: SortOrder
    addressText?: SortOrder
    phone?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gpsAccuracy?: SortOrder
    verifiedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    regionId?: SortOrder
    municipalityId?: SortOrder
    vereda?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    gpsAccuracy?: SortOrder
  }

  export type EnumVisitSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitSource | EnumVisitSourceFieldRefInput<$PrismaModel>
    in?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitSourceWithAggregatesFilter<$PrismaModel> | $Enums.VisitSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitSourceFilter<$PrismaModel>
    _max?: NestedEnumVisitSourceFilter<$PrismaModel>
  }

  export type EnumVisitReliabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitReliability | EnumVisitReliabilityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitReliabilityWithAggregatesFilter<$PrismaModel> | $Enums.VisitReliability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitReliabilityFilter<$PrismaModel>
    _max?: NestedEnumVisitReliabilityFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type VisitRelationFilter = {
    is?: VisitWhereInput
    isNot?: VisitWhereInput
  }

  export type VisitLogCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type VisitLogMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type VisitLogMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedManyWithoutRegionInput = {
    create?: XOR<UserCreateWithoutRegionInput, UserUncheckedCreateWithoutRegionInput> | UserCreateWithoutRegionInput[] | UserUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRegionInput | UserCreateOrConnectWithoutRegionInput[]
    createMany?: UserCreateManyRegionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RegionalReportCreateNestedManyWithoutRegionInput = {
    create?: XOR<RegionalReportCreateWithoutRegionInput, RegionalReportUncheckedCreateWithoutRegionInput> | RegionalReportCreateWithoutRegionInput[] | RegionalReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutRegionInput | RegionalReportCreateOrConnectWithoutRegionInput[]
    createMany?: RegionalReportCreateManyRegionInputEnvelope
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutRegionInput = {
    create?: XOR<ReportCreateWithoutRegionInput, ReportUncheckedCreateWithoutRegionInput> | ReportCreateWithoutRegionInput[] | ReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRegionInput | ReportCreateOrConnectWithoutRegionInput[]
    createMany?: ReportCreateManyRegionInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type VisitCreateNestedManyWithoutRegionInput = {
    create?: XOR<VisitCreateWithoutRegionInput, VisitUncheckedCreateWithoutRegionInput> | VisitCreateWithoutRegionInput[] | VisitUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutRegionInput | VisitCreateOrConnectWithoutRegionInput[]
    createMany?: VisitCreateManyRegionInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutRegionInput = {
    create?: XOR<DocumentCreateWithoutRegionInput, DocumentUncheckedCreateWithoutRegionInput> | DocumentCreateWithoutRegionInput[] | DocumentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRegionInput | DocumentCreateOrConnectWithoutRegionInput[]
    createMany?: DocumentCreateManyRegionInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutAssignedRegionsInput = {
    create?: XOR<UserCreateWithoutAssignedRegionsInput, UserUncheckedCreateWithoutAssignedRegionsInput> | UserCreateWithoutAssignedRegionsInput[] | UserUncheckedCreateWithoutAssignedRegionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRegionsInput | UserCreateOrConnectWithoutAssignedRegionsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MunicipalityCreateNestedManyWithoutRegionInput = {
    create?: XOR<MunicipalityCreateWithoutRegionInput, MunicipalityUncheckedCreateWithoutRegionInput> | MunicipalityCreateWithoutRegionInput[] | MunicipalityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutRegionInput | MunicipalityCreateOrConnectWithoutRegionInput[]
    createMany?: MunicipalityCreateManyRegionInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<UserCreateWithoutRegionInput, UserUncheckedCreateWithoutRegionInput> | UserCreateWithoutRegionInput[] | UserUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRegionInput | UserCreateOrConnectWithoutRegionInput[]
    createMany?: UserCreateManyRegionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RegionalReportUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<RegionalReportCreateWithoutRegionInput, RegionalReportUncheckedCreateWithoutRegionInput> | RegionalReportCreateWithoutRegionInput[] | RegionalReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutRegionInput | RegionalReportCreateOrConnectWithoutRegionInput[]
    createMany?: RegionalReportCreateManyRegionInputEnvelope
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<ReportCreateWithoutRegionInput, ReportUncheckedCreateWithoutRegionInput> | ReportCreateWithoutRegionInput[] | ReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRegionInput | ReportCreateOrConnectWithoutRegionInput[]
    createMany?: ReportCreateManyRegionInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<VisitCreateWithoutRegionInput, VisitUncheckedCreateWithoutRegionInput> | VisitCreateWithoutRegionInput[] | VisitUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutRegionInput | VisitCreateOrConnectWithoutRegionInput[]
    createMany?: VisitCreateManyRegionInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<DocumentCreateWithoutRegionInput, DocumentUncheckedCreateWithoutRegionInput> | DocumentCreateWithoutRegionInput[] | DocumentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRegionInput | DocumentCreateOrConnectWithoutRegionInput[]
    createMany?: DocumentCreateManyRegionInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedRegionsInput = {
    create?: XOR<UserCreateWithoutAssignedRegionsInput, UserUncheckedCreateWithoutAssignedRegionsInput> | UserCreateWithoutAssignedRegionsInput[] | UserUncheckedCreateWithoutAssignedRegionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRegionsInput | UserCreateOrConnectWithoutAssignedRegionsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MunicipalityUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<MunicipalityCreateWithoutRegionInput, MunicipalityUncheckedCreateWithoutRegionInput> | MunicipalityCreateWithoutRegionInput[] | MunicipalityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutRegionInput | MunicipalityCreateOrConnectWithoutRegionInput[]
    createMany?: MunicipalityCreateManyRegionInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRegionNestedInput = {
    create?: XOR<UserCreateWithoutRegionInput, UserUncheckedCreateWithoutRegionInput> | UserCreateWithoutRegionInput[] | UserUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRegionInput | UserCreateOrConnectWithoutRegionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRegionInput | UserUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: UserCreateManyRegionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRegionInput | UserUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRegionInput | UserUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RegionalReportUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RegionalReportCreateWithoutRegionInput, RegionalReportUncheckedCreateWithoutRegionInput> | RegionalReportCreateWithoutRegionInput[] | RegionalReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutRegionInput | RegionalReportCreateOrConnectWithoutRegionInput[]
    upsert?: RegionalReportUpsertWithWhereUniqueWithoutRegionInput | RegionalReportUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RegionalReportCreateManyRegionInputEnvelope
    set?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    disconnect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    delete?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    update?: RegionalReportUpdateWithWhereUniqueWithoutRegionInput | RegionalReportUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RegionalReportUpdateManyWithWhereWithoutRegionInput | RegionalReportUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutRegionNestedInput = {
    create?: XOR<ReportCreateWithoutRegionInput, ReportUncheckedCreateWithoutRegionInput> | ReportCreateWithoutRegionInput[] | ReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRegionInput | ReportCreateOrConnectWithoutRegionInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutRegionInput | ReportUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: ReportCreateManyRegionInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutRegionInput | ReportUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutRegionInput | ReportUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type VisitUpdateManyWithoutRegionNestedInput = {
    create?: XOR<VisitCreateWithoutRegionInput, VisitUncheckedCreateWithoutRegionInput> | VisitCreateWithoutRegionInput[] | VisitUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutRegionInput | VisitCreateOrConnectWithoutRegionInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutRegionInput | VisitUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: VisitCreateManyRegionInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutRegionInput | VisitUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutRegionInput | VisitUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DocumentCreateWithoutRegionInput, DocumentUncheckedCreateWithoutRegionInput> | DocumentCreateWithoutRegionInput[] | DocumentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRegionInput | DocumentCreateOrConnectWithoutRegionInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRegionInput | DocumentUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DocumentCreateManyRegionInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRegionInput | DocumentUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRegionInput | DocumentUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUpdateManyWithoutAssignedRegionsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedRegionsInput, UserUncheckedCreateWithoutAssignedRegionsInput> | UserCreateWithoutAssignedRegionsInput[] | UserUncheckedCreateWithoutAssignedRegionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRegionsInput | UserCreateOrConnectWithoutAssignedRegionsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedRegionsInput | UserUpsertWithWhereUniqueWithoutAssignedRegionsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedRegionsInput | UserUpdateWithWhereUniqueWithoutAssignedRegionsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedRegionsInput | UserUpdateManyWithWhereWithoutAssignedRegionsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MunicipalityUpdateManyWithoutRegionNestedInput = {
    create?: XOR<MunicipalityCreateWithoutRegionInput, MunicipalityUncheckedCreateWithoutRegionInput> | MunicipalityCreateWithoutRegionInput[] | MunicipalityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutRegionInput | MunicipalityCreateOrConnectWithoutRegionInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutRegionInput | MunicipalityUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: MunicipalityCreateManyRegionInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutRegionInput | MunicipalityUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutRegionInput | MunicipalityUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<UserCreateWithoutRegionInput, UserUncheckedCreateWithoutRegionInput> | UserCreateWithoutRegionInput[] | UserUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRegionInput | UserCreateOrConnectWithoutRegionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRegionInput | UserUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: UserCreateManyRegionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRegionInput | UserUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRegionInput | UserUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RegionalReportUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RegionalReportCreateWithoutRegionInput, RegionalReportUncheckedCreateWithoutRegionInput> | RegionalReportCreateWithoutRegionInput[] | RegionalReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutRegionInput | RegionalReportCreateOrConnectWithoutRegionInput[]
    upsert?: RegionalReportUpsertWithWhereUniqueWithoutRegionInput | RegionalReportUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RegionalReportCreateManyRegionInputEnvelope
    set?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    disconnect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    delete?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    update?: RegionalReportUpdateWithWhereUniqueWithoutRegionInput | RegionalReportUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RegionalReportUpdateManyWithWhereWithoutRegionInput | RegionalReportUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<ReportCreateWithoutRegionInput, ReportUncheckedCreateWithoutRegionInput> | ReportCreateWithoutRegionInput[] | ReportUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRegionInput | ReportCreateOrConnectWithoutRegionInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutRegionInput | ReportUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: ReportCreateManyRegionInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutRegionInput | ReportUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutRegionInput | ReportUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<VisitCreateWithoutRegionInput, VisitUncheckedCreateWithoutRegionInput> | VisitCreateWithoutRegionInput[] | VisitUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutRegionInput | VisitCreateOrConnectWithoutRegionInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutRegionInput | VisitUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: VisitCreateManyRegionInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutRegionInput | VisitUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutRegionInput | VisitUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DocumentCreateWithoutRegionInput, DocumentUncheckedCreateWithoutRegionInput> | DocumentCreateWithoutRegionInput[] | DocumentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRegionInput | DocumentCreateOrConnectWithoutRegionInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRegionInput | DocumentUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DocumentCreateManyRegionInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRegionInput | DocumentUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRegionInput | DocumentUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedRegionsInput, UserUncheckedCreateWithoutAssignedRegionsInput> | UserCreateWithoutAssignedRegionsInput[] | UserUncheckedCreateWithoutAssignedRegionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRegionsInput | UserCreateOrConnectWithoutAssignedRegionsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedRegionsInput | UserUpsertWithWhereUniqueWithoutAssignedRegionsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedRegionsInput | UserUpdateWithWhereUniqueWithoutAssignedRegionsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedRegionsInput | UserUpdateManyWithWhereWithoutAssignedRegionsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MunicipalityUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<MunicipalityCreateWithoutRegionInput, MunicipalityUncheckedCreateWithoutRegionInput> | MunicipalityCreateWithoutRegionInput[] | MunicipalityUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutRegionInput | MunicipalityCreateOrConnectWithoutRegionInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutRegionInput | MunicipalityUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: MunicipalityCreateManyRegionInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutRegionInput | MunicipalityUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutRegionInput | MunicipalityUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutMunicipalitiesInput = {
    create?: XOR<RegionCreateWithoutMunicipalitiesInput, RegionUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutMunicipalitiesInput
    connect?: RegionWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<UserCreateWithoutMunicipalityInput, UserUncheckedCreateWithoutMunicipalityInput> | UserCreateWithoutMunicipalityInput[] | UserUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMunicipalityInput | UserCreateOrConnectWithoutMunicipalityInput[]
    createMany?: UserCreateManyMunicipalityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutAssignedMunicipalitiesInput = {
    create?: XOR<UserCreateWithoutAssignedMunicipalitiesInput, UserUncheckedCreateWithoutAssignedMunicipalitiesInput> | UserCreateWithoutAssignedMunicipalitiesInput[] | UserUncheckedCreateWithoutAssignedMunicipalitiesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMunicipalitiesInput | UserCreateOrConnectWithoutAssignedMunicipalitiesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RegionalReportCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<RegionalReportCreateWithoutMunicipalityInput, RegionalReportUncheckedCreateWithoutMunicipalityInput> | RegionalReportCreateWithoutMunicipalityInput[] | RegionalReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutMunicipalityInput | RegionalReportCreateOrConnectWithoutMunicipalityInput[]
    createMany?: RegionalReportCreateManyMunicipalityInputEnvelope
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<ReportCreateWithoutMunicipalityInput, ReportUncheckedCreateWithoutMunicipalityInput> | ReportCreateWithoutMunicipalityInput[] | ReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMunicipalityInput | ReportCreateOrConnectWithoutMunicipalityInput[]
    createMany?: ReportCreateManyMunicipalityInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type VisitCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<VisitCreateWithoutMunicipalityInput, VisitUncheckedCreateWithoutMunicipalityInput> | VisitCreateWithoutMunicipalityInput[] | VisitUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutMunicipalityInput | VisitCreateOrConnectWithoutMunicipalityInput[]
    createMany?: VisitCreateManyMunicipalityInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VeredaCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<VeredaCreateWithoutMunicipalityInput, VeredaUncheckedCreateWithoutMunicipalityInput> | VeredaCreateWithoutMunicipalityInput[] | VeredaUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutMunicipalityInput | VeredaCreateOrConnectWithoutMunicipalityInput[]
    createMany?: VeredaCreateManyMunicipalityInputEnvelope
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<UserCreateWithoutMunicipalityInput, UserUncheckedCreateWithoutMunicipalityInput> | UserCreateWithoutMunicipalityInput[] | UserUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMunicipalityInput | UserCreateOrConnectWithoutMunicipalityInput[]
    createMany?: UserCreateManyMunicipalityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput = {
    create?: XOR<UserCreateWithoutAssignedMunicipalitiesInput, UserUncheckedCreateWithoutAssignedMunicipalitiesInput> | UserCreateWithoutAssignedMunicipalitiesInput[] | UserUncheckedCreateWithoutAssignedMunicipalitiesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMunicipalitiesInput | UserCreateOrConnectWithoutAssignedMunicipalitiesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<RegionalReportCreateWithoutMunicipalityInput, RegionalReportUncheckedCreateWithoutMunicipalityInput> | RegionalReportCreateWithoutMunicipalityInput[] | RegionalReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutMunicipalityInput | RegionalReportCreateOrConnectWithoutMunicipalityInput[]
    createMany?: RegionalReportCreateManyMunicipalityInputEnvelope
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<ReportCreateWithoutMunicipalityInput, ReportUncheckedCreateWithoutMunicipalityInput> | ReportCreateWithoutMunicipalityInput[] | ReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMunicipalityInput | ReportCreateOrConnectWithoutMunicipalityInput[]
    createMany?: ReportCreateManyMunicipalityInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<VisitCreateWithoutMunicipalityInput, VisitUncheckedCreateWithoutMunicipalityInput> | VisitCreateWithoutMunicipalityInput[] | VisitUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutMunicipalityInput | VisitCreateOrConnectWithoutMunicipalityInput[]
    createMany?: VisitCreateManyMunicipalityInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VeredaUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<VeredaCreateWithoutMunicipalityInput, VeredaUncheckedCreateWithoutMunicipalityInput> | VeredaCreateWithoutMunicipalityInput[] | VeredaUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutMunicipalityInput | VeredaCreateOrConnectWithoutMunicipalityInput[]
    createMany?: VeredaCreateManyMunicipalityInputEnvelope
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput = {
    create?: XOR<RegionCreateWithoutMunicipalitiesInput, RegionUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutMunicipalitiesInput
    upsert?: RegionUpsertWithoutMunicipalitiesInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutMunicipalitiesInput, RegionUpdateWithoutMunicipalitiesInput>, RegionUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type UserUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<UserCreateWithoutMunicipalityInput, UserUncheckedCreateWithoutMunicipalityInput> | UserCreateWithoutMunicipalityInput[] | UserUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMunicipalityInput | UserCreateOrConnectWithoutMunicipalityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMunicipalityInput | UserUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: UserCreateManyMunicipalityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMunicipalityInput | UserUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMunicipalityInput | UserUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateManyWithoutAssignedMunicipalitiesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedMunicipalitiesInput, UserUncheckedCreateWithoutAssignedMunicipalitiesInput> | UserCreateWithoutAssignedMunicipalitiesInput[] | UserUncheckedCreateWithoutAssignedMunicipalitiesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMunicipalitiesInput | UserCreateOrConnectWithoutAssignedMunicipalitiesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedMunicipalitiesInput | UserUpsertWithWhereUniqueWithoutAssignedMunicipalitiesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedMunicipalitiesInput | UserUpdateWithWhereUniqueWithoutAssignedMunicipalitiesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedMunicipalitiesInput | UserUpdateManyWithWhereWithoutAssignedMunicipalitiesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RegionalReportUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<RegionalReportCreateWithoutMunicipalityInput, RegionalReportUncheckedCreateWithoutMunicipalityInput> | RegionalReportCreateWithoutMunicipalityInput[] | RegionalReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutMunicipalityInput | RegionalReportCreateOrConnectWithoutMunicipalityInput[]
    upsert?: RegionalReportUpsertWithWhereUniqueWithoutMunicipalityInput | RegionalReportUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: RegionalReportCreateManyMunicipalityInputEnvelope
    set?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    disconnect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    delete?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    update?: RegionalReportUpdateWithWhereUniqueWithoutMunicipalityInput | RegionalReportUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: RegionalReportUpdateManyWithWhereWithoutMunicipalityInput | RegionalReportUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<ReportCreateWithoutMunicipalityInput, ReportUncheckedCreateWithoutMunicipalityInput> | ReportCreateWithoutMunicipalityInput[] | ReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMunicipalityInput | ReportCreateOrConnectWithoutMunicipalityInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutMunicipalityInput | ReportUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: ReportCreateManyMunicipalityInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutMunicipalityInput | ReportUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutMunicipalityInput | ReportUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type VisitUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<VisitCreateWithoutMunicipalityInput, VisitUncheckedCreateWithoutMunicipalityInput> | VisitCreateWithoutMunicipalityInput[] | VisitUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutMunicipalityInput | VisitCreateOrConnectWithoutMunicipalityInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutMunicipalityInput | VisitUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: VisitCreateManyMunicipalityInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutMunicipalityInput | VisitUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutMunicipalityInput | VisitUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VeredaUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<VeredaCreateWithoutMunicipalityInput, VeredaUncheckedCreateWithoutMunicipalityInput> | VeredaCreateWithoutMunicipalityInput[] | VeredaUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutMunicipalityInput | VeredaCreateOrConnectWithoutMunicipalityInput[]
    upsert?: VeredaUpsertWithWhereUniqueWithoutMunicipalityInput | VeredaUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: VeredaCreateManyMunicipalityInputEnvelope
    set?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    disconnect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    delete?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    update?: VeredaUpdateWithWhereUniqueWithoutMunicipalityInput | VeredaUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: VeredaUpdateManyWithWhereWithoutMunicipalityInput | VeredaUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: VeredaScalarWhereInput | VeredaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<UserCreateWithoutMunicipalityInput, UserUncheckedCreateWithoutMunicipalityInput> | UserCreateWithoutMunicipalityInput[] | UserUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMunicipalityInput | UserCreateOrConnectWithoutMunicipalityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMunicipalityInput | UserUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: UserCreateManyMunicipalityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMunicipalityInput | UserUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMunicipalityInput | UserUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedMunicipalitiesInput, UserUncheckedCreateWithoutAssignedMunicipalitiesInput> | UserCreateWithoutAssignedMunicipalitiesInput[] | UserUncheckedCreateWithoutAssignedMunicipalitiesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMunicipalitiesInput | UserCreateOrConnectWithoutAssignedMunicipalitiesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedMunicipalitiesInput | UserUpsertWithWhereUniqueWithoutAssignedMunicipalitiesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedMunicipalitiesInput | UserUpdateWithWhereUniqueWithoutAssignedMunicipalitiesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedMunicipalitiesInput | UserUpdateManyWithWhereWithoutAssignedMunicipalitiesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<RegionalReportCreateWithoutMunicipalityInput, RegionalReportUncheckedCreateWithoutMunicipalityInput> | RegionalReportCreateWithoutMunicipalityInput[] | RegionalReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutMunicipalityInput | RegionalReportCreateOrConnectWithoutMunicipalityInput[]
    upsert?: RegionalReportUpsertWithWhereUniqueWithoutMunicipalityInput | RegionalReportUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: RegionalReportCreateManyMunicipalityInputEnvelope
    set?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    disconnect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    delete?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    update?: RegionalReportUpdateWithWhereUniqueWithoutMunicipalityInput | RegionalReportUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: RegionalReportUpdateManyWithWhereWithoutMunicipalityInput | RegionalReportUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<ReportCreateWithoutMunicipalityInput, ReportUncheckedCreateWithoutMunicipalityInput> | ReportCreateWithoutMunicipalityInput[] | ReportUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMunicipalityInput | ReportCreateOrConnectWithoutMunicipalityInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutMunicipalityInput | ReportUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: ReportCreateManyMunicipalityInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutMunicipalityInput | ReportUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutMunicipalityInput | ReportUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<VisitCreateWithoutMunicipalityInput, VisitUncheckedCreateWithoutMunicipalityInput> | VisitCreateWithoutMunicipalityInput[] | VisitUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutMunicipalityInput | VisitCreateOrConnectWithoutMunicipalityInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutMunicipalityInput | VisitUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: VisitCreateManyMunicipalityInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutMunicipalityInput | VisitUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutMunicipalityInput | VisitUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<VeredaCreateWithoutMunicipalityInput, VeredaUncheckedCreateWithoutMunicipalityInput> | VeredaCreateWithoutMunicipalityInput[] | VeredaUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutMunicipalityInput | VeredaCreateOrConnectWithoutMunicipalityInput[]
    upsert?: VeredaUpsertWithWhereUniqueWithoutMunicipalityInput | VeredaUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: VeredaCreateManyMunicipalityInputEnvelope
    set?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    disconnect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    delete?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    update?: VeredaUpdateWithWhereUniqueWithoutMunicipalityInput | VeredaUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: VeredaUpdateManyWithWhereWithoutMunicipalityInput | VeredaUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: VeredaScalarWhereInput | VeredaScalarWhereInput[]
  }

  export type MunicipalityCreateNestedOneWithoutVeredasInput = {
    create?: XOR<MunicipalityCreateWithoutVeredasInput, MunicipalityUncheckedCreateWithoutVeredasInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutVeredasInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAssignedVeredasInput = {
    create?: XOR<UserCreateWithoutAssignedVeredasInput, UserUncheckedCreateWithoutAssignedVeredasInput> | UserCreateWithoutAssignedVeredasInput[] | UserUncheckedCreateWithoutAssignedVeredasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVeredasInput | UserCreateOrConnectWithoutAssignedVeredasInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedVeredasInput = {
    create?: XOR<UserCreateWithoutAssignedVeredasInput, UserUncheckedCreateWithoutAssignedVeredasInput> | UserCreateWithoutAssignedVeredasInput[] | UserUncheckedCreateWithoutAssignedVeredasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVeredasInput | UserCreateOrConnectWithoutAssignedVeredasInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MunicipalityUpdateOneRequiredWithoutVeredasNestedInput = {
    create?: XOR<MunicipalityCreateWithoutVeredasInput, MunicipalityUncheckedCreateWithoutVeredasInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutVeredasInput
    upsert?: MunicipalityUpsertWithoutVeredasInput
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutVeredasInput, MunicipalityUpdateWithoutVeredasInput>, MunicipalityUncheckedUpdateWithoutVeredasInput>
  }

  export type UserUpdateManyWithoutAssignedVeredasNestedInput = {
    create?: XOR<UserCreateWithoutAssignedVeredasInput, UserUncheckedCreateWithoutAssignedVeredasInput> | UserCreateWithoutAssignedVeredasInput[] | UserUncheckedCreateWithoutAssignedVeredasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVeredasInput | UserCreateOrConnectWithoutAssignedVeredasInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedVeredasInput | UserUpsertWithWhereUniqueWithoutAssignedVeredasInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedVeredasInput | UserUpdateWithWhereUniqueWithoutAssignedVeredasInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedVeredasInput | UserUpdateManyWithWhereWithoutAssignedVeredasInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedVeredasNestedInput = {
    create?: XOR<UserCreateWithoutAssignedVeredasInput, UserUncheckedCreateWithoutAssignedVeredasInput> | UserCreateWithoutAssignedVeredasInput[] | UserUncheckedCreateWithoutAssignedVeredasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVeredasInput | UserCreateOrConnectWithoutAssignedVeredasInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedVeredasInput | UserUpsertWithWhereUniqueWithoutAssignedVeredasInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedVeredasInput | UserUpdateWithWhereUniqueWithoutAssignedVeredasInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedVeredasInput | UserUpdateManyWithWhereWithoutAssignedVeredasInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutUsersInput = {
    create?: XOR<RegionCreateWithoutUsersInput, RegionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutUsersInput
    connect?: RegionWhereUniqueInput
  }

  export type MunicipalityCreateNestedOneWithoutUsersInput = {
    create?: XOR<MunicipalityCreateWithoutUsersInput, MunicipalityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutUsersInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutAssignedUsersInput = {
    create?: XOR<RegionCreateWithoutAssignedUsersInput, RegionUncheckedCreateWithoutAssignedUsersInput> | RegionCreateWithoutAssignedUsersInput[] | RegionUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutAssignedUsersInput | RegionCreateOrConnectWithoutAssignedUsersInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type MunicipalityCreateNestedManyWithoutAssignedUsersInput = {
    create?: XOR<MunicipalityCreateWithoutAssignedUsersInput, MunicipalityUncheckedCreateWithoutAssignedUsersInput> | MunicipalityCreateWithoutAssignedUsersInput[] | MunicipalityUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAssignedUsersInput | MunicipalityCreateOrConnectWithoutAssignedUsersInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type VeredaCreateNestedManyWithoutAssignedUsersInput = {
    create?: XOR<VeredaCreateWithoutAssignedUsersInput, VeredaUncheckedCreateWithoutAssignedUsersInput> | VeredaCreateWithoutAssignedUsersInput[] | VeredaUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutAssignedUsersInput | VeredaCreateOrConnectWithoutAssignedUsersInput[]
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type RegionalReportCreateNestedManyWithoutUserInput = {
    create?: XOR<RegionalReportCreateWithoutUserInput, RegionalReportUncheckedCreateWithoutUserInput> | RegionalReportCreateWithoutUserInput[] | RegionalReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutUserInput | RegionalReportCreateOrConnectWithoutUserInput[]
    createMany?: RegionalReportCreateManyUserInputEnvelope
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutGeneratedByInput = {
    create?: XOR<ReportCreateWithoutGeneratedByInput, ReportUncheckedCreateWithoutGeneratedByInput> | ReportCreateWithoutGeneratedByInput[] | ReportUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratedByInput | ReportCreateOrConnectWithoutGeneratedByInput[]
    createMany?: ReportCreateManyGeneratedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutAuthorizedByInput = {
    create?: XOR<ReportCreateWithoutAuthorizedByInput, ReportUncheckedCreateWithoutAuthorizedByInput> | ReportCreateWithoutAuthorizedByInput[] | ReportUncheckedCreateWithoutAuthorizedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorizedByInput | ReportCreateOrConnectWithoutAuthorizedByInput[]
    createMany?: ReportCreateManyAuthorizedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type NewsReadReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<NewsReadReceiptCreateWithoutUserInput, NewsReadReceiptUncheckedCreateWithoutUserInput> | NewsReadReceiptCreateWithoutUserInput[] | NewsReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutUserInput | NewsReadReceiptCreateOrConnectWithoutUserInput[]
    createMany?: NewsReadReceiptCreateManyUserInputEnvelope
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
  }

  export type VisitCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<VisitCreateWithoutAssignedToInput, VisitUncheckedCreateWithoutAssignedToInput> | VisitCreateWithoutAssignedToInput[] | VisitUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedToInput | VisitCreateOrConnectWithoutAssignedToInput[]
    createMany?: VisitCreateManyAssignedToInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<VisitCreateWithoutAssignedByInput, VisitUncheckedCreateWithoutAssignedByInput> | VisitCreateWithoutAssignedByInput[] | VisitUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedByInput | VisitCreateOrConnectWithoutAssignedByInput[]
    createMany?: VisitCreateManyAssignedByInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitLogCreateNestedManyWithoutUserInput = {
    create?: XOR<VisitLogCreateWithoutUserInput, VisitLogUncheckedCreateWithoutUserInput> | VisitLogCreateWithoutUserInput[] | VisitLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutUserInput | VisitLogCreateOrConnectWithoutUserInput[]
    createMany?: VisitLogCreateManyUserInputEnvelope
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutAssignedUsersInput = {
    create?: XOR<RegionCreateWithoutAssignedUsersInput, RegionUncheckedCreateWithoutAssignedUsersInput> | RegionCreateWithoutAssignedUsersInput[] | RegionUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutAssignedUsersInput | RegionCreateOrConnectWithoutAssignedUsersInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput = {
    create?: XOR<MunicipalityCreateWithoutAssignedUsersInput, MunicipalityUncheckedCreateWithoutAssignedUsersInput> | MunicipalityCreateWithoutAssignedUsersInput[] | MunicipalityUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAssignedUsersInput | MunicipalityCreateOrConnectWithoutAssignedUsersInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput = {
    create?: XOR<VeredaCreateWithoutAssignedUsersInput, VeredaUncheckedCreateWithoutAssignedUsersInput> | VeredaCreateWithoutAssignedUsersInput[] | VeredaUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutAssignedUsersInput | VeredaCreateOrConnectWithoutAssignedUsersInput[]
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type RegionalReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RegionalReportCreateWithoutUserInput, RegionalReportUncheckedCreateWithoutUserInput> | RegionalReportCreateWithoutUserInput[] | RegionalReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutUserInput | RegionalReportCreateOrConnectWithoutUserInput[]
    createMany?: RegionalReportCreateManyUserInputEnvelope
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutGeneratedByInput = {
    create?: XOR<ReportCreateWithoutGeneratedByInput, ReportUncheckedCreateWithoutGeneratedByInput> | ReportCreateWithoutGeneratedByInput[] | ReportUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratedByInput | ReportCreateOrConnectWithoutGeneratedByInput[]
    createMany?: ReportCreateManyGeneratedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutAuthorizedByInput = {
    create?: XOR<ReportCreateWithoutAuthorizedByInput, ReportUncheckedCreateWithoutAuthorizedByInput> | ReportCreateWithoutAuthorizedByInput[] | ReportUncheckedCreateWithoutAuthorizedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorizedByInput | ReportCreateOrConnectWithoutAuthorizedByInput[]
    createMany?: ReportCreateManyAuthorizedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NewsReadReceiptCreateWithoutUserInput, NewsReadReceiptUncheckedCreateWithoutUserInput> | NewsReadReceiptCreateWithoutUserInput[] | NewsReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutUserInput | NewsReadReceiptCreateOrConnectWithoutUserInput[]
    createMany?: NewsReadReceiptCreateManyUserInputEnvelope
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<VisitCreateWithoutAssignedToInput, VisitUncheckedCreateWithoutAssignedToInput> | VisitCreateWithoutAssignedToInput[] | VisitUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedToInput | VisitCreateOrConnectWithoutAssignedToInput[]
    createMany?: VisitCreateManyAssignedToInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<VisitCreateWithoutAssignedByInput, VisitUncheckedCreateWithoutAssignedByInput> | VisitCreateWithoutAssignedByInput[] | VisitUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedByInput | VisitCreateOrConnectWithoutAssignedByInput[]
    createMany?: VisitCreateManyAssignedByInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VisitLogCreateWithoutUserInput, VisitLogUncheckedCreateWithoutUserInput> | VisitLogCreateWithoutUserInput[] | VisitLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutUserInput | VisitLogCreateOrConnectWithoutUserInput[]
    createMany?: VisitLogCreateManyUserInputEnvelope
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RegionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RegionCreateWithoutUsersInput, RegionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutUsersInput
    upsert?: RegionUpsertWithoutUsersInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutUsersInput, RegionUpdateWithoutUsersInput>, RegionUncheckedUpdateWithoutUsersInput>
  }

  export type MunicipalityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MunicipalityCreateWithoutUsersInput, MunicipalityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutUsersInput
    upsert?: MunicipalityUpsertWithoutUsersInput
    disconnect?: MunicipalityWhereInput | boolean
    delete?: MunicipalityWhereInput | boolean
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutUsersInput, MunicipalityUpdateWithoutUsersInput>, MunicipalityUncheckedUpdateWithoutUsersInput>
  }

  export type RegionUpdateManyWithoutAssignedUsersNestedInput = {
    create?: XOR<RegionCreateWithoutAssignedUsersInput, RegionUncheckedCreateWithoutAssignedUsersInput> | RegionCreateWithoutAssignedUsersInput[] | RegionUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutAssignedUsersInput | RegionCreateOrConnectWithoutAssignedUsersInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutAssignedUsersInput | RegionUpsertWithWhereUniqueWithoutAssignedUsersInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutAssignedUsersInput | RegionUpdateWithWhereUniqueWithoutAssignedUsersInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutAssignedUsersInput | RegionUpdateManyWithWhereWithoutAssignedUsersInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type MunicipalityUpdateManyWithoutAssignedUsersNestedInput = {
    create?: XOR<MunicipalityCreateWithoutAssignedUsersInput, MunicipalityUncheckedCreateWithoutAssignedUsersInput> | MunicipalityCreateWithoutAssignedUsersInput[] | MunicipalityUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAssignedUsersInput | MunicipalityCreateOrConnectWithoutAssignedUsersInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutAssignedUsersInput | MunicipalityUpsertWithWhereUniqueWithoutAssignedUsersInput[]
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutAssignedUsersInput | MunicipalityUpdateWithWhereUniqueWithoutAssignedUsersInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutAssignedUsersInput | MunicipalityUpdateManyWithWhereWithoutAssignedUsersInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type VeredaUpdateManyWithoutAssignedUsersNestedInput = {
    create?: XOR<VeredaCreateWithoutAssignedUsersInput, VeredaUncheckedCreateWithoutAssignedUsersInput> | VeredaCreateWithoutAssignedUsersInput[] | VeredaUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutAssignedUsersInput | VeredaCreateOrConnectWithoutAssignedUsersInput[]
    upsert?: VeredaUpsertWithWhereUniqueWithoutAssignedUsersInput | VeredaUpsertWithWhereUniqueWithoutAssignedUsersInput[]
    set?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    disconnect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    delete?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    update?: VeredaUpdateWithWhereUniqueWithoutAssignedUsersInput | VeredaUpdateWithWhereUniqueWithoutAssignedUsersInput[]
    updateMany?: VeredaUpdateManyWithWhereWithoutAssignedUsersInput | VeredaUpdateManyWithWhereWithoutAssignedUsersInput[]
    deleteMany?: VeredaScalarWhereInput | VeredaScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploaderInput | DocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploaderInput | DocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploaderInput | DocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutUserInput | DocumentCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutUserInput | DocumentCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutUserInput | DocumentCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type RegionalReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegionalReportCreateWithoutUserInput, RegionalReportUncheckedCreateWithoutUserInput> | RegionalReportCreateWithoutUserInput[] | RegionalReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutUserInput | RegionalReportCreateOrConnectWithoutUserInput[]
    upsert?: RegionalReportUpsertWithWhereUniqueWithoutUserInput | RegionalReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegionalReportCreateManyUserInputEnvelope
    set?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    disconnect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    delete?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    update?: RegionalReportUpdateWithWhereUniqueWithoutUserInput | RegionalReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegionalReportUpdateManyWithWhereWithoutUserInput | RegionalReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutGeneratedByNestedInput = {
    create?: XOR<ReportCreateWithoutGeneratedByInput, ReportUncheckedCreateWithoutGeneratedByInput> | ReportCreateWithoutGeneratedByInput[] | ReportUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratedByInput | ReportCreateOrConnectWithoutGeneratedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGeneratedByInput | ReportUpsertWithWhereUniqueWithoutGeneratedByInput[]
    createMany?: ReportCreateManyGeneratedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGeneratedByInput | ReportUpdateWithWhereUniqueWithoutGeneratedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGeneratedByInput | ReportUpdateManyWithWhereWithoutGeneratedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutAuthorizedByNestedInput = {
    create?: XOR<ReportCreateWithoutAuthorizedByInput, ReportUncheckedCreateWithoutAuthorizedByInput> | ReportCreateWithoutAuthorizedByInput[] | ReportUncheckedCreateWithoutAuthorizedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorizedByInput | ReportCreateOrConnectWithoutAuthorizedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAuthorizedByInput | ReportUpsertWithWhereUniqueWithoutAuthorizedByInput[]
    createMany?: ReportCreateManyAuthorizedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAuthorizedByInput | ReportUpdateWithWhereUniqueWithoutAuthorizedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAuthorizedByInput | ReportUpdateManyWithWhereWithoutAuthorizedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type NewsReadReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<NewsReadReceiptCreateWithoutUserInput, NewsReadReceiptUncheckedCreateWithoutUserInput> | NewsReadReceiptCreateWithoutUserInput[] | NewsReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutUserInput | NewsReadReceiptCreateOrConnectWithoutUserInput[]
    upsert?: NewsReadReceiptUpsertWithWhereUniqueWithoutUserInput | NewsReadReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NewsReadReceiptCreateManyUserInputEnvelope
    set?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    disconnect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    delete?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    update?: NewsReadReceiptUpdateWithWhereUniqueWithoutUserInput | NewsReadReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NewsReadReceiptUpdateManyWithWhereWithoutUserInput | NewsReadReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NewsReadReceiptScalarWhereInput | NewsReadReceiptScalarWhereInput[]
  }

  export type VisitUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<VisitCreateWithoutAssignedToInput, VisitUncheckedCreateWithoutAssignedToInput> | VisitCreateWithoutAssignedToInput[] | VisitUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedToInput | VisitCreateOrConnectWithoutAssignedToInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutAssignedToInput | VisitUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: VisitCreateManyAssignedToInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutAssignedToInput | VisitUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutAssignedToInput | VisitUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<VisitCreateWithoutAssignedByInput, VisitUncheckedCreateWithoutAssignedByInput> | VisitCreateWithoutAssignedByInput[] | VisitUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedByInput | VisitCreateOrConnectWithoutAssignedByInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutAssignedByInput | VisitUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: VisitCreateManyAssignedByInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutAssignedByInput | VisitUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutAssignedByInput | VisitUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<VisitLogCreateWithoutUserInput, VisitLogUncheckedCreateWithoutUserInput> | VisitLogCreateWithoutUserInput[] | VisitLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutUserInput | VisitLogCreateOrConnectWithoutUserInput[]
    upsert?: VisitLogUpsertWithWhereUniqueWithoutUserInput | VisitLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VisitLogCreateManyUserInputEnvelope
    set?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    disconnect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    delete?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    update?: VisitLogUpdateWithWhereUniqueWithoutUserInput | VisitLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VisitLogUpdateManyWithWhereWithoutUserInput | VisitLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VisitLogScalarWhereInput | VisitLogScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput = {
    create?: XOR<RegionCreateWithoutAssignedUsersInput, RegionUncheckedCreateWithoutAssignedUsersInput> | RegionCreateWithoutAssignedUsersInput[] | RegionUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutAssignedUsersInput | RegionCreateOrConnectWithoutAssignedUsersInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutAssignedUsersInput | RegionUpsertWithWhereUniqueWithoutAssignedUsersInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutAssignedUsersInput | RegionUpdateWithWhereUniqueWithoutAssignedUsersInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutAssignedUsersInput | RegionUpdateManyWithWhereWithoutAssignedUsersInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput = {
    create?: XOR<MunicipalityCreateWithoutAssignedUsersInput, MunicipalityUncheckedCreateWithoutAssignedUsersInput> | MunicipalityCreateWithoutAssignedUsersInput[] | MunicipalityUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAssignedUsersInput | MunicipalityCreateOrConnectWithoutAssignedUsersInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutAssignedUsersInput | MunicipalityUpsertWithWhereUniqueWithoutAssignedUsersInput[]
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutAssignedUsersInput | MunicipalityUpdateWithWhereUniqueWithoutAssignedUsersInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutAssignedUsersInput | MunicipalityUpdateManyWithWhereWithoutAssignedUsersInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput = {
    create?: XOR<VeredaCreateWithoutAssignedUsersInput, VeredaUncheckedCreateWithoutAssignedUsersInput> | VeredaCreateWithoutAssignedUsersInput[] | VeredaUncheckedCreateWithoutAssignedUsersInput[]
    connectOrCreate?: VeredaCreateOrConnectWithoutAssignedUsersInput | VeredaCreateOrConnectWithoutAssignedUsersInput[]
    upsert?: VeredaUpsertWithWhereUniqueWithoutAssignedUsersInput | VeredaUpsertWithWhereUniqueWithoutAssignedUsersInput[]
    set?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    disconnect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    delete?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    connect?: VeredaWhereUniqueInput | VeredaWhereUniqueInput[]
    update?: VeredaUpdateWithWhereUniqueWithoutAssignedUsersInput | VeredaUpdateWithWhereUniqueWithoutAssignedUsersInput[]
    updateMany?: VeredaUpdateManyWithWhereWithoutAssignedUsersInput | VeredaUpdateManyWithWhereWithoutAssignedUsersInput[]
    deleteMany?: VeredaScalarWhereInput | VeredaScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploaderInput | DocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploaderInput | DocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploaderInput | DocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutUserInput | DocumentCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutUserInput | DocumentCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutUserInput | DocumentCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type RegionalReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegionalReportCreateWithoutUserInput, RegionalReportUncheckedCreateWithoutUserInput> | RegionalReportCreateWithoutUserInput[] | RegionalReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionalReportCreateOrConnectWithoutUserInput | RegionalReportCreateOrConnectWithoutUserInput[]
    upsert?: RegionalReportUpsertWithWhereUniqueWithoutUserInput | RegionalReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegionalReportCreateManyUserInputEnvelope
    set?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    disconnect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    delete?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    connect?: RegionalReportWhereUniqueInput | RegionalReportWhereUniqueInput[]
    update?: RegionalReportUpdateWithWhereUniqueWithoutUserInput | RegionalReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegionalReportUpdateManyWithWhereWithoutUserInput | RegionalReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutGeneratedByNestedInput = {
    create?: XOR<ReportCreateWithoutGeneratedByInput, ReportUncheckedCreateWithoutGeneratedByInput> | ReportCreateWithoutGeneratedByInput[] | ReportUncheckedCreateWithoutGeneratedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratedByInput | ReportCreateOrConnectWithoutGeneratedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGeneratedByInput | ReportUpsertWithWhereUniqueWithoutGeneratedByInput[]
    createMany?: ReportCreateManyGeneratedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGeneratedByInput | ReportUpdateWithWhereUniqueWithoutGeneratedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGeneratedByInput | ReportUpdateManyWithWhereWithoutGeneratedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput = {
    create?: XOR<ReportCreateWithoutAuthorizedByInput, ReportUncheckedCreateWithoutAuthorizedByInput> | ReportCreateWithoutAuthorizedByInput[] | ReportUncheckedCreateWithoutAuthorizedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorizedByInput | ReportCreateOrConnectWithoutAuthorizedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAuthorizedByInput | ReportUpsertWithWhereUniqueWithoutAuthorizedByInput[]
    createMany?: ReportCreateManyAuthorizedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAuthorizedByInput | ReportUpdateWithWhereUniqueWithoutAuthorizedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAuthorizedByInput | ReportUpdateManyWithWhereWithoutAuthorizedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NewsReadReceiptCreateWithoutUserInput, NewsReadReceiptUncheckedCreateWithoutUserInput> | NewsReadReceiptCreateWithoutUserInput[] | NewsReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutUserInput | NewsReadReceiptCreateOrConnectWithoutUserInput[]
    upsert?: NewsReadReceiptUpsertWithWhereUniqueWithoutUserInput | NewsReadReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NewsReadReceiptCreateManyUserInputEnvelope
    set?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    disconnect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    delete?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    update?: NewsReadReceiptUpdateWithWhereUniqueWithoutUserInput | NewsReadReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NewsReadReceiptUpdateManyWithWhereWithoutUserInput | NewsReadReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NewsReadReceiptScalarWhereInput | NewsReadReceiptScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<VisitCreateWithoutAssignedToInput, VisitUncheckedCreateWithoutAssignedToInput> | VisitCreateWithoutAssignedToInput[] | VisitUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedToInput | VisitCreateOrConnectWithoutAssignedToInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutAssignedToInput | VisitUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: VisitCreateManyAssignedToInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutAssignedToInput | VisitUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutAssignedToInput | VisitUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<VisitCreateWithoutAssignedByInput, VisitUncheckedCreateWithoutAssignedByInput> | VisitCreateWithoutAssignedByInput[] | VisitUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutAssignedByInput | VisitCreateOrConnectWithoutAssignedByInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutAssignedByInput | VisitUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: VisitCreateManyAssignedByInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutAssignedByInput | VisitUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutAssignedByInput | VisitUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VisitLogCreateWithoutUserInput, VisitLogUncheckedCreateWithoutUserInput> | VisitLogCreateWithoutUserInput[] | VisitLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutUserInput | VisitLogCreateOrConnectWithoutUserInput[]
    upsert?: VisitLogUpsertWithWhereUniqueWithoutUserInput | VisitLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VisitLogCreateManyUserInputEnvelope
    set?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    disconnect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    delete?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    update?: VisitLogUpdateWithWhereUniqueWithoutUserInput | VisitLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VisitLogUpdateManyWithWhereWithoutUserInput | VisitLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VisitLogScalarWhereInput | VisitLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<RegionCreateWithoutDocumentsInput, RegionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDocumentsInput
    connect?: RegionWhereUniqueInput
  }

  export type DocumentCommentCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentInput, DocumentCommentUncheckedCreateWithoutDocumentInput> | DocumentCommentCreateWithoutDocumentInput[] | DocumentCommentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentInput | DocumentCommentCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentCommentCreateManyDocumentInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type DocumentCommentUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentInput, DocumentCommentUncheckedCreateWithoutDocumentInput> | DocumentCommentCreateWithoutDocumentInput[] | DocumentCommentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentInput | DocumentCommentCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentCommentCreateManyDocumentInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type RegionUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<RegionCreateWithoutDocumentsInput, RegionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDocumentsInput
    upsert?: RegionUpsertWithoutDocumentsInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutDocumentsInput, RegionUpdateWithoutDocumentsInput>, RegionUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentCommentUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentInput, DocumentCommentUncheckedCreateWithoutDocumentInput> | DocumentCommentCreateWithoutDocumentInput[] | DocumentCommentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentInput | DocumentCommentCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput | DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentCommentCreateManyDocumentInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput | DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutDocumentInput | DocumentCommentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentCommentUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentInput, DocumentCommentUncheckedCreateWithoutDocumentInput> | DocumentCommentCreateWithoutDocumentInput[] | DocumentCommentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentInput | DocumentCommentCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput | DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentCommentCreateManyDocumentInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput | DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutDocumentInput | DocumentCommentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutCommentsInput = {
    create?: XOR<DocumentCreateWithoutCommentsInput, DocumentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCommentsInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<DocumentCreateWithoutCommentsInput, DocumentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCommentsInput
    upsert?: DocumentUpsertWithoutCommentsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutCommentsInput, DocumentUpdateWithoutCommentsInput>, DocumentUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutNewsInput = {
    create?: XOR<UserCreateWithoutNewsInput, UserUncheckedCreateWithoutNewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNewsInput
    connect?: UserWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutReportsInput = {
    create?: XOR<RegionCreateWithoutReportsInput, RegionUncheckedCreateWithoutReportsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutReportsInput
    connect?: RegionWhereUniqueInput
  }

  export type MunicipalityCreateNestedOneWithoutReportsInput = {
    create?: XOR<MunicipalityCreateWithoutReportsInput, MunicipalityUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutReportsInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutReportInput = {
    create?: XOR<AlertCreateWithoutReportInput, AlertUncheckedCreateWithoutReportInput> | AlertCreateWithoutReportInput[] | AlertUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutReportInput | AlertCreateOrConnectWithoutReportInput[]
    createMany?: AlertCreateManyReportInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type NewsReadReceiptCreateNestedManyWithoutReportInput = {
    create?: XOR<NewsReadReceiptCreateWithoutReportInput, NewsReadReceiptUncheckedCreateWithoutReportInput> | NewsReadReceiptCreateWithoutReportInput[] | NewsReadReceiptUncheckedCreateWithoutReportInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutReportInput | NewsReadReceiptCreateOrConnectWithoutReportInput[]
    createMany?: NewsReadReceiptCreateManyReportInputEnvelope
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<AlertCreateWithoutReportInput, AlertUncheckedCreateWithoutReportInput> | AlertCreateWithoutReportInput[] | AlertUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutReportInput | AlertCreateOrConnectWithoutReportInput[]
    createMany?: AlertCreateManyReportInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type NewsReadReceiptUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<NewsReadReceiptCreateWithoutReportInput, NewsReadReceiptUncheckedCreateWithoutReportInput> | NewsReadReceiptCreateWithoutReportInput[] | NewsReadReceiptUncheckedCreateWithoutReportInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutReportInput | NewsReadReceiptCreateOrConnectWithoutReportInput[]
    createMany?: NewsReadReceiptCreateManyReportInputEnvelope
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
  }

  export type EnumNewsCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NewsCategory
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type UserUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<UserCreateWithoutNewsInput, UserUncheckedCreateWithoutNewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNewsInput
    upsert?: UserUpsertWithoutNewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNewsInput, UserUpdateWithoutNewsInput>, UserUncheckedUpdateWithoutNewsInput>
  }

  export type RegionUpdateOneWithoutReportsNestedInput = {
    create?: XOR<RegionCreateWithoutReportsInput, RegionUncheckedCreateWithoutReportsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutReportsInput
    upsert?: RegionUpsertWithoutReportsInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutReportsInput, RegionUpdateWithoutReportsInput>, RegionUncheckedUpdateWithoutReportsInput>
  }

  export type MunicipalityUpdateOneWithoutReportsNestedInput = {
    create?: XOR<MunicipalityCreateWithoutReportsInput, MunicipalityUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutReportsInput
    upsert?: MunicipalityUpsertWithoutReportsInput
    disconnect?: MunicipalityWhereInput | boolean
    delete?: MunicipalityWhereInput | boolean
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutReportsInput, MunicipalityUpdateWithoutReportsInput>, MunicipalityUncheckedUpdateWithoutReportsInput>
  }

  export type AlertUpdateManyWithoutReportNestedInput = {
    create?: XOR<AlertCreateWithoutReportInput, AlertUncheckedCreateWithoutReportInput> | AlertCreateWithoutReportInput[] | AlertUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutReportInput | AlertCreateOrConnectWithoutReportInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutReportInput | AlertUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: AlertCreateManyReportInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutReportInput | AlertUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutReportInput | AlertUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type NewsReadReceiptUpdateManyWithoutReportNestedInput = {
    create?: XOR<NewsReadReceiptCreateWithoutReportInput, NewsReadReceiptUncheckedCreateWithoutReportInput> | NewsReadReceiptCreateWithoutReportInput[] | NewsReadReceiptUncheckedCreateWithoutReportInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutReportInput | NewsReadReceiptCreateOrConnectWithoutReportInput[]
    upsert?: NewsReadReceiptUpsertWithWhereUniqueWithoutReportInput | NewsReadReceiptUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: NewsReadReceiptCreateManyReportInputEnvelope
    set?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    disconnect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    delete?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    update?: NewsReadReceiptUpdateWithWhereUniqueWithoutReportInput | NewsReadReceiptUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: NewsReadReceiptUpdateManyWithWhereWithoutReportInput | NewsReadReceiptUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: NewsReadReceiptScalarWhereInput | NewsReadReceiptScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<AlertCreateWithoutReportInput, AlertUncheckedCreateWithoutReportInput> | AlertCreateWithoutReportInput[] | AlertUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutReportInput | AlertCreateOrConnectWithoutReportInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutReportInput | AlertUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: AlertCreateManyReportInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutReportInput | AlertUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutReportInput | AlertUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type NewsReadReceiptUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<NewsReadReceiptCreateWithoutReportInput, NewsReadReceiptUncheckedCreateWithoutReportInput> | NewsReadReceiptCreateWithoutReportInput[] | NewsReadReceiptUncheckedCreateWithoutReportInput[]
    connectOrCreate?: NewsReadReceiptCreateOrConnectWithoutReportInput | NewsReadReceiptCreateOrConnectWithoutReportInput[]
    upsert?: NewsReadReceiptUpsertWithWhereUniqueWithoutReportInput | NewsReadReceiptUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: NewsReadReceiptCreateManyReportInputEnvelope
    set?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    disconnect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    delete?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    connect?: NewsReadReceiptWhereUniqueInput | NewsReadReceiptWhereUniqueInput[]
    update?: NewsReadReceiptUpdateWithWhereUniqueWithoutReportInput | NewsReadReceiptUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: NewsReadReceiptUpdateManyWithWhereWithoutReportInput | NewsReadReceiptUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: NewsReadReceiptScalarWhereInput | NewsReadReceiptScalarWhereInput[]
  }

  export type RegionalReportCreateNestedOneWithoutAlertsInput = {
    create?: XOR<RegionalReportCreateWithoutAlertsInput, RegionalReportUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: RegionalReportCreateOrConnectWithoutAlertsInput
    connect?: RegionalReportWhereUniqueInput
  }

  export type RegionalReportUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<RegionalReportCreateWithoutAlertsInput, RegionalReportUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: RegionalReportCreateOrConnectWithoutAlertsInput
    upsert?: RegionalReportUpsertWithoutAlertsInput
    connect?: RegionalReportWhereUniqueInput
    update?: XOR<XOR<RegionalReportUpdateToOneWithWhereWithoutAlertsInput, RegionalReportUpdateWithoutAlertsInput>, RegionalReportUncheckedUpdateWithoutAlertsInput>
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthorizedReportsInput = {
    create?: XOR<UserCreateWithoutAuthorizedReportsInput, UserUncheckedCreateWithoutAuthorizedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorizedReportsInput
    connect?: UserWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutGeneratedReportsInput = {
    create?: XOR<RegionCreateWithoutGeneratedReportsInput, RegionUncheckedCreateWithoutGeneratedReportsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutGeneratedReportsInput
    connect?: RegionWhereUniqueInput
  }

  export type MunicipalityCreateNestedOneWithoutGeneratedReportsInput = {
    create?: XOR<MunicipalityCreateWithoutGeneratedReportsInput, MunicipalityUncheckedCreateWithoutGeneratedReportsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutGeneratedReportsInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type ReportDeliveryCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportDeliveryCreateWithoutReportInput, ReportDeliveryUncheckedCreateWithoutReportInput> | ReportDeliveryCreateWithoutReportInput[] | ReportDeliveryUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDeliveryCreateOrConnectWithoutReportInput | ReportDeliveryCreateOrConnectWithoutReportInput[]
    createMany?: ReportDeliveryCreateManyReportInputEnvelope
    connect?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
  }

  export type ReportDeliveryUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportDeliveryCreateWithoutReportInput, ReportDeliveryUncheckedCreateWithoutReportInput> | ReportDeliveryCreateWithoutReportInput[] | ReportDeliveryUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDeliveryCreateOrConnectWithoutReportInput | ReportDeliveryCreateOrConnectWithoutReportInput[]
    createMany?: ReportDeliveryCreateManyReportInputEnvelope
    connect?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportFormatFieldUpdateOperationsInput = {
    set?: $Enums.ReportFormat
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneWithoutAuthorizedReportsNestedInput = {
    create?: XOR<UserCreateWithoutAuthorizedReportsInput, UserUncheckedCreateWithoutAuthorizedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorizedReportsInput
    upsert?: UserUpsertWithoutAuthorizedReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorizedReportsInput, UserUpdateWithoutAuthorizedReportsInput>, UserUncheckedUpdateWithoutAuthorizedReportsInput>
  }

  export type RegionUpdateOneWithoutGeneratedReportsNestedInput = {
    create?: XOR<RegionCreateWithoutGeneratedReportsInput, RegionUncheckedCreateWithoutGeneratedReportsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutGeneratedReportsInput
    upsert?: RegionUpsertWithoutGeneratedReportsInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutGeneratedReportsInput, RegionUpdateWithoutGeneratedReportsInput>, RegionUncheckedUpdateWithoutGeneratedReportsInput>
  }

  export type MunicipalityUpdateOneWithoutGeneratedReportsNestedInput = {
    create?: XOR<MunicipalityCreateWithoutGeneratedReportsInput, MunicipalityUncheckedCreateWithoutGeneratedReportsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutGeneratedReportsInput
    upsert?: MunicipalityUpsertWithoutGeneratedReportsInput
    disconnect?: MunicipalityWhereInput | boolean
    delete?: MunicipalityWhereInput | boolean
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutGeneratedReportsInput, MunicipalityUpdateWithoutGeneratedReportsInput>, MunicipalityUncheckedUpdateWithoutGeneratedReportsInput>
  }

  export type ReportDeliveryUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportDeliveryCreateWithoutReportInput, ReportDeliveryUncheckedCreateWithoutReportInput> | ReportDeliveryCreateWithoutReportInput[] | ReportDeliveryUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDeliveryCreateOrConnectWithoutReportInput | ReportDeliveryCreateOrConnectWithoutReportInput[]
    upsert?: ReportDeliveryUpsertWithWhereUniqueWithoutReportInput | ReportDeliveryUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportDeliveryCreateManyReportInputEnvelope
    set?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    disconnect?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    delete?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    connect?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    update?: ReportDeliveryUpdateWithWhereUniqueWithoutReportInput | ReportDeliveryUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportDeliveryUpdateManyWithWhereWithoutReportInput | ReportDeliveryUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportDeliveryScalarWhereInput | ReportDeliveryScalarWhereInput[]
  }

  export type ReportDeliveryUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportDeliveryCreateWithoutReportInput, ReportDeliveryUncheckedCreateWithoutReportInput> | ReportDeliveryCreateWithoutReportInput[] | ReportDeliveryUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDeliveryCreateOrConnectWithoutReportInput | ReportDeliveryCreateOrConnectWithoutReportInput[]
    upsert?: ReportDeliveryUpsertWithWhereUniqueWithoutReportInput | ReportDeliveryUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportDeliveryCreateManyReportInputEnvelope
    set?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    disconnect?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    delete?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    connect?: ReportDeliveryWhereUniqueInput | ReportDeliveryWhereUniqueInput[]
    update?: ReportDeliveryUpdateWithWhereUniqueWithoutReportInput | ReportDeliveryUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportDeliveryUpdateManyWithWhereWithoutReportInput | ReportDeliveryUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportDeliveryScalarWhereInput | ReportDeliveryScalarWhereInput[]
  }

  export type ReportCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<ReportCreateWithoutDeliveriesInput, ReportUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutDeliveriesInput
    connect?: ReportWhereUniqueInput
  }

  export type EnumDeliveryChannelFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryChannel
  }

  export type ReportUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<ReportCreateWithoutDeliveriesInput, ReportUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutDeliveriesInput
    upsert?: ReportUpsertWithoutDeliveriesInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutDeliveriesInput, ReportUpdateWithoutDeliveriesInput>, ReportUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserCreateNestedOneWithoutReadReceiptsInput = {
    create?: XOR<UserCreateWithoutReadReceiptsInput, UserUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadReceiptsInput
    connect?: UserWhereUniqueInput
  }

  export type RegionalReportCreateNestedOneWithoutReadReceiptsInput = {
    create?: XOR<RegionalReportCreateWithoutReadReceiptsInput, RegionalReportUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: RegionalReportCreateOrConnectWithoutReadReceiptsInput
    connect?: RegionalReportWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReadReceiptsNestedInput = {
    create?: XOR<UserCreateWithoutReadReceiptsInput, UserUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadReceiptsInput
    upsert?: UserUpsertWithoutReadReceiptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReadReceiptsInput, UserUpdateWithoutReadReceiptsInput>, UserUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type RegionalReportUpdateOneRequiredWithoutReadReceiptsNestedInput = {
    create?: XOR<RegionalReportCreateWithoutReadReceiptsInput, RegionalReportUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: RegionalReportCreateOrConnectWithoutReadReceiptsInput
    upsert?: RegionalReportUpsertWithoutReadReceiptsInput
    connect?: RegionalReportWhereUniqueInput
    update?: XOR<XOR<RegionalReportUpdateToOneWithWhereWithoutReadReceiptsInput, RegionalReportUpdateWithoutReadReceiptsInput>, RegionalReportUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type RegionCreateNestedOneWithoutVisitsInput = {
    create?: XOR<RegionCreateWithoutVisitsInput, RegionUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutVisitsInput
    connect?: RegionWhereUniqueInput
  }

  export type MunicipalityCreateNestedOneWithoutVisitsInput = {
    create?: XOR<MunicipalityCreateWithoutVisitsInput, MunicipalityUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutVisitsInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedVisitsInput = {
    create?: XOR<UserCreateWithoutAssignedVisitsInput, UserUncheckedCreateWithoutAssignedVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDelegatedVisitsInput = {
    create?: XOR<UserCreateWithoutDelegatedVisitsInput, UserUncheckedCreateWithoutDelegatedVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDelegatedVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitLogCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitLogCreateWithoutVisitInput, VisitLogUncheckedCreateWithoutVisitInput> | VisitLogCreateWithoutVisitInput[] | VisitLogUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutVisitInput | VisitLogCreateOrConnectWithoutVisitInput[]
    createMany?: VisitLogCreateManyVisitInputEnvelope
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
  }

  export type VisitLogUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitLogCreateWithoutVisitInput, VisitLogUncheckedCreateWithoutVisitInput> | VisitLogCreateWithoutVisitInput[] | VisitLogUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutVisitInput | VisitLogCreateOrConnectWithoutVisitInput[]
    createMany?: VisitLogCreateManyVisitInputEnvelope
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
  }

  export type EnumVisitSourceFieldUpdateOperationsInput = {
    set?: $Enums.VisitSource
  }

  export type EnumVisitReliabilityFieldUpdateOperationsInput = {
    set?: $Enums.VisitReliability
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVisitStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitStatus
  }

  export type RegionUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<RegionCreateWithoutVisitsInput, RegionUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutVisitsInput
    upsert?: RegionUpsertWithoutVisitsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutVisitsInput, RegionUpdateWithoutVisitsInput>, RegionUncheckedUpdateWithoutVisitsInput>
  }

  export type MunicipalityUpdateOneWithoutVisitsNestedInput = {
    create?: XOR<MunicipalityCreateWithoutVisitsInput, MunicipalityUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutVisitsInput
    upsert?: MunicipalityUpsertWithoutVisitsInput
    disconnect?: MunicipalityWhereInput | boolean
    delete?: MunicipalityWhereInput | boolean
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutVisitsInput, MunicipalityUpdateWithoutVisitsInput>, MunicipalityUncheckedUpdateWithoutVisitsInput>
  }

  export type UserUpdateOneWithoutAssignedVisitsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedVisitsInput, UserUncheckedCreateWithoutAssignedVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVisitsInput
    upsert?: UserUpsertWithoutAssignedVisitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedVisitsInput, UserUpdateWithoutAssignedVisitsInput>, UserUncheckedUpdateWithoutAssignedVisitsInput>
  }

  export type UserUpdateOneWithoutDelegatedVisitsNestedInput = {
    create?: XOR<UserCreateWithoutDelegatedVisitsInput, UserUncheckedCreateWithoutDelegatedVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDelegatedVisitsInput
    upsert?: UserUpsertWithoutDelegatedVisitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDelegatedVisitsInput, UserUpdateWithoutDelegatedVisitsInput>, UserUncheckedUpdateWithoutDelegatedVisitsInput>
  }

  export type VisitLogUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitLogCreateWithoutVisitInput, VisitLogUncheckedCreateWithoutVisitInput> | VisitLogCreateWithoutVisitInput[] | VisitLogUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutVisitInput | VisitLogCreateOrConnectWithoutVisitInput[]
    upsert?: VisitLogUpsertWithWhereUniqueWithoutVisitInput | VisitLogUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitLogCreateManyVisitInputEnvelope
    set?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    disconnect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    delete?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    update?: VisitLogUpdateWithWhereUniqueWithoutVisitInput | VisitLogUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitLogUpdateManyWithWhereWithoutVisitInput | VisitLogUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitLogScalarWhereInput | VisitLogScalarWhereInput[]
  }

  export type VisitLogUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitLogCreateWithoutVisitInput, VisitLogUncheckedCreateWithoutVisitInput> | VisitLogCreateWithoutVisitInput[] | VisitLogUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitLogCreateOrConnectWithoutVisitInput | VisitLogCreateOrConnectWithoutVisitInput[]
    upsert?: VisitLogUpsertWithWhereUniqueWithoutVisitInput | VisitLogUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitLogCreateManyVisitInputEnvelope
    set?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    disconnect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    delete?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    connect?: VisitLogWhereUniqueInput | VisitLogWhereUniqueInput[]
    update?: VisitLogUpdateWithWhereUniqueWithoutVisitInput | VisitLogUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitLogUpdateManyWithWhereWithoutVisitInput | VisitLogUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitLogScalarWhereInput | VisitLogScalarWhereInput[]
  }

  export type VisitCreateNestedOneWithoutLogsInput = {
    create?: XOR<VisitCreateWithoutLogsInput, VisitUncheckedCreateWithoutLogsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutLogsInput
    connect?: VisitWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVisitLogsInput = {
    create?: XOR<UserCreateWithoutVisitLogsInput, UserUncheckedCreateWithoutVisitLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitLogsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<VisitCreateWithoutLogsInput, VisitUncheckedCreateWithoutLogsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutLogsInput
    upsert?: VisitUpsertWithoutLogsInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutLogsInput, VisitUpdateWithoutLogsInput>, VisitUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneRequiredWithoutVisitLogsNestedInput = {
    create?: XOR<UserCreateWithoutVisitLogsInput, UserUncheckedCreateWithoutVisitLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitLogsInput
    upsert?: UserUpsertWithoutVisitLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVisitLogsInput, UserUpdateWithoutVisitLogsInput>, UserUncheckedUpdateWithoutVisitLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumNewsCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsCategory | EnumNewsCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsCategoryFilter<$PrismaModel> | $Enums.NewsCategory
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumNewsCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsCategory | EnumNewsCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsCategory[] | ListEnumNewsCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NewsCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNewsCategoryFilter<$PrismaModel>
    _max?: NestedEnumNewsCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatFilter<$PrismaModel> | $Enums.ReportFormat
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ReportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFormatFilter<$PrismaModel>
    _max?: NestedEnumReportFormatFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryChannel | EnumDeliveryChannelFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryChannelFilter<$PrismaModel> | $Enums.DeliveryChannel
  }

  export type NestedEnumDeliveryChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryChannel | EnumDeliveryChannelFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryChannel[] | ListEnumDeliveryChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryChannelWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryChannelFilter<$PrismaModel>
    _max?: NestedEnumDeliveryChannelFilter<$PrismaModel>
  }

  export type NestedEnumVisitSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitSource | EnumVisitSourceFieldRefInput<$PrismaModel>
    in?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitSourceFilter<$PrismaModel> | $Enums.VisitSource
  }

  export type NestedEnumVisitReliabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitReliability | EnumVisitReliabilityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitReliabilityFilter<$PrismaModel> | $Enums.VisitReliability
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type NestedEnumVisitSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitSource | EnumVisitSourceFieldRefInput<$PrismaModel>
    in?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitSource[] | ListEnumVisitSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitSourceWithAggregatesFilter<$PrismaModel> | $Enums.VisitSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitSourceFilter<$PrismaModel>
    _max?: NestedEnumVisitSourceFilter<$PrismaModel>
  }

  export type NestedEnumVisitReliabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitReliability | EnumVisitReliabilityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitReliability[] | ListEnumVisitReliabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitReliabilityWithAggregatesFilter<$PrismaModel> | $Enums.VisitReliability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitReliabilityFilter<$PrismaModel>
    _max?: NestedEnumVisitReliabilityFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRegionInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRegionInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRegionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegionInput, UserUncheckedCreateWithoutRegionInput>
  }

  export type UserCreateManyRegionInputEnvelope = {
    data: UserCreateManyRegionInput | UserCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type RegionalReportCreateWithoutRegionInput = {
    id?: string
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNewsInput
    municipality?: MunicipalityCreateNestedOneWithoutReportsInput
    alerts?: AlertCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUncheckedCreateWithoutRegionInput = {
    id?: string
    userId: string
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutReportInput
  }

  export type RegionalReportCreateOrConnectWithoutRegionInput = {
    where: RegionalReportWhereUniqueInput
    create: XOR<RegionalReportCreateWithoutRegionInput, RegionalReportUncheckedCreateWithoutRegionInput>
  }

  export type RegionalReportCreateManyRegionInputEnvelope = {
    data: RegionalReportCreateManyRegionInput | RegionalReportCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutRegionInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy: UserCreateNestedOneWithoutReportsInput
    authorizedBy?: UserCreateNestedOneWithoutAuthorizedReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutGeneratedReportsInput
    deliveries?: ReportDeliveryCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutRegionInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    deliveries?: ReportDeliveryUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutRegionInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutRegionInput, ReportUncheckedCreateWithoutRegionInput>
  }

  export type ReportCreateManyRegionInputEnvelope = {
    data: ReportCreateManyRegionInput | ReportCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutRegionInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    vereda?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    municipality?: MunicipalityCreateNestedOneWithoutVisitsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedVisitsInput
    assignedBy?: UserCreateNestedOneWithoutDelegatedVisitsInput
    logs?: VisitLogCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutRegionInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: VisitLogUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutRegionInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutRegionInput, VisitUncheckedCreateWithoutRegionInput>
  }

  export type VisitCreateManyRegionInputEnvelope = {
    data: VisitCreateManyRegionInput | VisitCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutRegionInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutDocumentsInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutRegionInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    uploaderId: string
    createdAt?: Date | string
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutRegionInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutRegionInput, DocumentUncheckedCreateWithoutRegionInput>
  }

  export type DocumentCreateManyRegionInputEnvelope = {
    data: DocumentCreateManyRegionInput | DocumentCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAssignedRegionsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedRegionsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedRegionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedRegionsInput, UserUncheckedCreateWithoutAssignedRegionsInput>
  }

  export type MunicipalityCreateWithoutRegionInput = {
    id?: string
    name: string
    users?: UserCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutRegionInput = {
    id?: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutRegionInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutRegionInput, MunicipalityUncheckedCreateWithoutRegionInput>
  }

  export type MunicipalityCreateManyRegionInputEnvelope = {
    data: MunicipalityCreateManyRegionInput | MunicipalityCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRegionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRegionInput, UserUncheckedUpdateWithoutRegionInput>
    create: XOR<UserCreateWithoutRegionInput, UserUncheckedCreateWithoutRegionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRegionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRegionInput, UserUncheckedUpdateWithoutRegionInput>
  }

  export type UserUpdateManyWithWhereWithoutRegionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRegionInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    dni?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    permissions?: JsonFilter<"User">
    regionId?: StringNullableFilter<"User"> | string | null
    municipalityId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    acceptedTerms?: BoolFilter<"User"> | boolean
    acceptedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type RegionalReportUpsertWithWhereUniqueWithoutRegionInput = {
    where: RegionalReportWhereUniqueInput
    update: XOR<RegionalReportUpdateWithoutRegionInput, RegionalReportUncheckedUpdateWithoutRegionInput>
    create: XOR<RegionalReportCreateWithoutRegionInput, RegionalReportUncheckedCreateWithoutRegionInput>
  }

  export type RegionalReportUpdateWithWhereUniqueWithoutRegionInput = {
    where: RegionalReportWhereUniqueInput
    data: XOR<RegionalReportUpdateWithoutRegionInput, RegionalReportUncheckedUpdateWithoutRegionInput>
  }

  export type RegionalReportUpdateManyWithWhereWithoutRegionInput = {
    where: RegionalReportScalarWhereInput
    data: XOR<RegionalReportUpdateManyMutationInput, RegionalReportUncheckedUpdateManyWithoutRegionInput>
  }

  export type RegionalReportScalarWhereInput = {
    AND?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
    OR?: RegionalReportScalarWhereInput[]
    NOT?: RegionalReportScalarWhereInput | RegionalReportScalarWhereInput[]
    id?: StringFilter<"RegionalReport"> | string
    userId?: StringFilter<"RegionalReport"> | string
    regionId?: StringNullableFilter<"RegionalReport"> | string | null
    municipalityId?: StringNullableFilter<"RegionalReport"> | string | null
    category?: EnumNewsCategoryFilter<"RegionalReport"> | $Enums.NewsCategory
    priority?: EnumPriorityFilter<"RegionalReport"> | $Enums.Priority
    title?: StringFilter<"RegionalReport"> | string
    content?: StringFilter<"RegionalReport"> | string
    createdAt?: DateTimeFilter<"RegionalReport"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutRegionInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutRegionInput, ReportUncheckedUpdateWithoutRegionInput>
    create: XOR<ReportCreateWithoutRegionInput, ReportUncheckedCreateWithoutRegionInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutRegionInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutRegionInput, ReportUncheckedUpdateWithoutRegionInput>
  }

  export type ReportUpdateManyWithWhereWithoutRegionInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutRegionInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    code?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"Report"> | $Enums.ReportFormat
    url?: StringFilter<"Report"> | string
    hashSha256?: StringFilter<"Report"> | string
    generatedById?: StringFilter<"Report"> | string
    authorizedById?: StringNullableFilter<"Report"> | string | null
    regionId?: StringNullableFilter<"Report"> | string | null
    municipalityId?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
    generatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type VisitUpsertWithWhereUniqueWithoutRegionInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutRegionInput, VisitUncheckedUpdateWithoutRegionInput>
    create: XOR<VisitCreateWithoutRegionInput, VisitUncheckedCreateWithoutRegionInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutRegionInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutRegionInput, VisitUncheckedUpdateWithoutRegionInput>
  }

  export type VisitUpdateManyWithWhereWithoutRegionInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutRegionInput>
  }

  export type VisitScalarWhereInput = {
    AND?: VisitScalarWhereInput | VisitScalarWhereInput[]
    OR?: VisitScalarWhereInput[]
    NOT?: VisitScalarWhereInput | VisitScalarWhereInput[]
    id?: StringFilter<"Visit"> | string
    source?: EnumVisitSourceFilter<"Visit"> | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFilter<"Visit"> | $Enums.VisitReliability
    citizenId?: StringNullableFilter<"Visit"> | string | null
    fullName?: StringNullableFilter<"Visit"> | string | null
    addressText?: StringFilter<"Visit"> | string
    phone?: StringNullableFilter<"Visit"> | string | null
    latitude?: FloatNullableFilter<"Visit"> | number | null
    longitude?: FloatNullableFilter<"Visit"> | number | null
    gpsAccuracy?: FloatNullableFilter<"Visit"> | number | null
    verifiedAt?: DateTimeNullableFilter<"Visit"> | Date | string | null
    status?: EnumVisitStatusFilter<"Visit"> | $Enums.VisitStatus
    priority?: EnumPriorityFilter<"Visit"> | $Enums.Priority
    regionId?: StringFilter<"Visit"> | string
    municipalityId?: StringNullableFilter<"Visit"> | string | null
    vereda?: StringNullableFilter<"Visit"> | string | null
    assignedToId?: StringNullableFilter<"Visit"> | string | null
    assignedById?: StringNullableFilter<"Visit"> | string | null
    assignedAt?: DateTimeNullableFilter<"Visit"> | Date | string | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutRegionInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutRegionInput, DocumentUncheckedUpdateWithoutRegionInput>
    create: XOR<DocumentCreateWithoutRegionInput, DocumentUncheckedCreateWithoutRegionInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutRegionInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutRegionInput, DocumentUncheckedUpdateWithoutRegionInput>
  }

  export type DocumentUpdateManyWithWhereWithoutRegionInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutRegionInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    version?: IntFilter<"Document"> | number
    hash?: StringNullableFilter<"Document"> | string | null
    uploaderId?: StringFilter<"Document"> | string
    regionId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedRegionsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedRegionsInput, UserUncheckedUpdateWithoutAssignedRegionsInput>
    create: XOR<UserCreateWithoutAssignedRegionsInput, UserUncheckedCreateWithoutAssignedRegionsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedRegionsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedRegionsInput, UserUncheckedUpdateWithoutAssignedRegionsInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedRegionsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedRegionsInput>
  }

  export type MunicipalityUpsertWithWhereUniqueWithoutRegionInput = {
    where: MunicipalityWhereUniqueInput
    update: XOR<MunicipalityUpdateWithoutRegionInput, MunicipalityUncheckedUpdateWithoutRegionInput>
    create: XOR<MunicipalityCreateWithoutRegionInput, MunicipalityUncheckedCreateWithoutRegionInput>
  }

  export type MunicipalityUpdateWithWhereUniqueWithoutRegionInput = {
    where: MunicipalityWhereUniqueInput
    data: XOR<MunicipalityUpdateWithoutRegionInput, MunicipalityUncheckedUpdateWithoutRegionInput>
  }

  export type MunicipalityUpdateManyWithWhereWithoutRegionInput = {
    where: MunicipalityScalarWhereInput
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyWithoutRegionInput>
  }

  export type MunicipalityScalarWhereInput = {
    AND?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    OR?: MunicipalityScalarWhereInput[]
    NOT?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    id?: StringFilter<"Municipality"> | string
    name?: StringFilter<"Municipality"> | string
    regionId?: StringFilter<"Municipality"> | string
  }

  export type RegionCreateWithoutMunicipalitiesInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
  }

  export type RegionUncheckedCreateWithoutMunicipalitiesInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
  }

  export type RegionCreateOrConnectWithoutMunicipalitiesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutMunicipalitiesInput, RegionUncheckedCreateWithoutMunicipalitiesInput>
  }

  export type UserCreateWithoutMunicipalityInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMunicipalityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMunicipalityInput, UserUncheckedCreateWithoutMunicipalityInput>
  }

  export type UserCreateManyMunicipalityInputEnvelope = {
    data: UserCreateManyMunicipalityInput | UserCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAssignedMunicipalitiesInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedMunicipalitiesInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedMunicipalitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedMunicipalitiesInput, UserUncheckedCreateWithoutAssignedMunicipalitiesInput>
  }

  export type RegionalReportCreateWithoutMunicipalityInput = {
    id?: string
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNewsInput
    region?: RegionCreateNestedOneWithoutReportsInput
    alerts?: AlertCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    userId: string
    regionId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutReportInput
  }

  export type RegionalReportCreateOrConnectWithoutMunicipalityInput = {
    where: RegionalReportWhereUniqueInput
    create: XOR<RegionalReportCreateWithoutMunicipalityInput, RegionalReportUncheckedCreateWithoutMunicipalityInput>
  }

  export type RegionalReportCreateManyMunicipalityInputEnvelope = {
    data: RegionalReportCreateManyMunicipalityInput | RegionalReportCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutMunicipalityInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy: UserCreateNestedOneWithoutReportsInput
    authorizedBy?: UserCreateNestedOneWithoutAuthorizedReportsInput
    region?: RegionCreateNestedOneWithoutGeneratedReportsInput
    deliveries?: ReportDeliveryCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    regionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    deliveries?: ReportDeliveryUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutMunicipalityInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutMunicipalityInput, ReportUncheckedCreateWithoutMunicipalityInput>
  }

  export type ReportCreateManyMunicipalityInputEnvelope = {
    data: ReportCreateManyMunicipalityInput | ReportCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutMunicipalityInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    vereda?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    region: RegionCreateNestedOneWithoutVisitsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedVisitsInput
    assignedBy?: UserCreateNestedOneWithoutDelegatedVisitsInput
    logs?: VisitLogCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: VisitLogUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutMunicipalityInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutMunicipalityInput, VisitUncheckedCreateWithoutMunicipalityInput>
  }

  export type VisitCreateManyMunicipalityInputEnvelope = {
    data: VisitCreateManyMunicipalityInput | VisitCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type VeredaCreateWithoutMunicipalityInput = {
    id?: string
    name: string
    assignedUsers?: UserCreateNestedManyWithoutAssignedVeredasInput
  }

  export type VeredaUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    name: string
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedVeredasInput
  }

  export type VeredaCreateOrConnectWithoutMunicipalityInput = {
    where: VeredaWhereUniqueInput
    create: XOR<VeredaCreateWithoutMunicipalityInput, VeredaUncheckedCreateWithoutMunicipalityInput>
  }

  export type VeredaCreateManyMunicipalityInputEnvelope = {
    data: VeredaCreateManyMunicipalityInput | VeredaCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutMunicipalitiesInput = {
    update: XOR<RegionUpdateWithoutMunicipalitiesInput, RegionUncheckedUpdateWithoutMunicipalitiesInput>
    create: XOR<RegionCreateWithoutMunicipalitiesInput, RegionUncheckedCreateWithoutMunicipalitiesInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutMunicipalitiesInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutMunicipalitiesInput, RegionUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type RegionUpdateWithoutMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutMunicipalityInput, UserUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<UserCreateWithoutMunicipalityInput, UserUncheckedCreateWithoutMunicipalityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutMunicipalityInput, UserUncheckedUpdateWithoutMunicipalityInput>
  }

  export type UserUpdateManyWithWhereWithoutMunicipalityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedMunicipalitiesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedMunicipalitiesInput, UserUncheckedUpdateWithoutAssignedMunicipalitiesInput>
    create: XOR<UserCreateWithoutAssignedMunicipalitiesInput, UserUncheckedCreateWithoutAssignedMunicipalitiesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedMunicipalitiesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedMunicipalitiesInput, UserUncheckedUpdateWithoutAssignedMunicipalitiesInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedMunicipalitiesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedMunicipalitiesInput>
  }

  export type RegionalReportUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: RegionalReportWhereUniqueInput
    update: XOR<RegionalReportUpdateWithoutMunicipalityInput, RegionalReportUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<RegionalReportCreateWithoutMunicipalityInput, RegionalReportUncheckedCreateWithoutMunicipalityInput>
  }

  export type RegionalReportUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: RegionalReportWhereUniqueInput
    data: XOR<RegionalReportUpdateWithoutMunicipalityInput, RegionalReportUncheckedUpdateWithoutMunicipalityInput>
  }

  export type RegionalReportUpdateManyWithWhereWithoutMunicipalityInput = {
    where: RegionalReportScalarWhereInput
    data: XOR<RegionalReportUpdateManyMutationInput, RegionalReportUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutMunicipalityInput, ReportUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<ReportCreateWithoutMunicipalityInput, ReportUncheckedCreateWithoutMunicipalityInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutMunicipalityInput, ReportUncheckedUpdateWithoutMunicipalityInput>
  }

  export type ReportUpdateManyWithWhereWithoutMunicipalityInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type VisitUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutMunicipalityInput, VisitUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<VisitCreateWithoutMunicipalityInput, VisitUncheckedCreateWithoutMunicipalityInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutMunicipalityInput, VisitUncheckedUpdateWithoutMunicipalityInput>
  }

  export type VisitUpdateManyWithWhereWithoutMunicipalityInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type VeredaUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: VeredaWhereUniqueInput
    update: XOR<VeredaUpdateWithoutMunicipalityInput, VeredaUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<VeredaCreateWithoutMunicipalityInput, VeredaUncheckedCreateWithoutMunicipalityInput>
  }

  export type VeredaUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: VeredaWhereUniqueInput
    data: XOR<VeredaUpdateWithoutMunicipalityInput, VeredaUncheckedUpdateWithoutMunicipalityInput>
  }

  export type VeredaUpdateManyWithWhereWithoutMunicipalityInput = {
    where: VeredaScalarWhereInput
    data: XOR<VeredaUpdateManyMutationInput, VeredaUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type VeredaScalarWhereInput = {
    AND?: VeredaScalarWhereInput | VeredaScalarWhereInput[]
    OR?: VeredaScalarWhereInput[]
    NOT?: VeredaScalarWhereInput | VeredaScalarWhereInput[]
    id?: StringFilter<"Vereda"> | string
    name?: StringFilter<"Vereda"> | string
    municipalityId?: StringFilter<"Vereda"> | string
  }

  export type MunicipalityCreateWithoutVeredasInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    users?: UserCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutVeredasInput = {
    id?: string
    name: string
    regionId: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutVeredasInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutVeredasInput, MunicipalityUncheckedCreateWithoutVeredasInput>
  }

  export type UserCreateWithoutAssignedVeredasInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedVeredasInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedVeredasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedVeredasInput, UserUncheckedCreateWithoutAssignedVeredasInput>
  }

  export type MunicipalityUpsertWithoutVeredasInput = {
    update: XOR<MunicipalityUpdateWithoutVeredasInput, MunicipalityUncheckedUpdateWithoutVeredasInput>
    create: XOR<MunicipalityCreateWithoutVeredasInput, MunicipalityUncheckedCreateWithoutVeredasInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutVeredasInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutVeredasInput, MunicipalityUncheckedUpdateWithoutVeredasInput>
  }

  export type MunicipalityUpdateWithoutVeredasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutVeredasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedVeredasInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedVeredasInput, UserUncheckedUpdateWithoutAssignedVeredasInput>
    create: XOR<UserCreateWithoutAssignedVeredasInput, UserUncheckedCreateWithoutAssignedVeredasInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedVeredasInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedVeredasInput, UserUncheckedUpdateWithoutAssignedVeredasInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedVeredasInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedVeredasInput>
  }

  export type RegionCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutUsersInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutUsersInput, RegionUncheckedCreateWithoutUsersInput>
  }

  export type MunicipalityCreateWithoutUsersInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    regionId: string
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutUsersInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutUsersInput, MunicipalityUncheckedCreateWithoutUsersInput>
  }

  export type RegionCreateWithoutAssignedUsersInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutAssignedUsersInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutAssignedUsersInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutAssignedUsersInput, RegionUncheckedCreateWithoutAssignedUsersInput>
  }

  export type MunicipalityCreateWithoutAssignedUsersInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    users?: UserCreateNestedManyWithoutMunicipalityInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutAssignedUsersInput = {
    id?: string
    name: string
    regionId: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutAssignedUsersInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutAssignedUsersInput, MunicipalityUncheckedCreateWithoutAssignedUsersInput>
  }

  export type VeredaCreateWithoutAssignedUsersInput = {
    id?: string
    name: string
    municipality: MunicipalityCreateNestedOneWithoutVeredasInput
  }

  export type VeredaUncheckedCreateWithoutAssignedUsersInput = {
    id?: string
    name: string
    municipalityId: string
  }

  export type VeredaCreateOrConnectWithoutAssignedUsersInput = {
    where: VeredaWhereUniqueInput
    create: XOR<VeredaCreateWithoutAssignedUsersInput, VeredaUncheckedCreateWithoutAssignedUsersInput>
  }

  export type DocumentCreateWithoutUploaderInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    createdAt?: Date | string
    region?: RegionCreateNestedOneWithoutDocumentsInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    regionId?: string | null
    createdAt?: Date | string
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentCreateManyUploaderInputEnvelope = {
    data: DocumentCreateManyUploaderInput | DocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutCommentsInput
  }

  export type DocumentCommentUncheckedCreateWithoutUserInput = {
    id?: string
    documentId: string
    content: string
    createdAt?: Date | string
  }

  export type DocumentCommentCreateOrConnectWithoutUserInput = {
    where: DocumentCommentWhereUniqueInput
    create: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCommentCreateManyUserInputEnvelope = {
    data: DocumentCommentCreateManyUserInput | DocumentCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RegionalReportCreateWithoutUserInput = {
    id?: string
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    region?: RegionCreateNestedOneWithoutReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutReportsInput
    alerts?: AlertCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUncheckedCreateWithoutUserInput = {
    id?: string
    regionId?: string | null
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutReportInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutReportInput
  }

  export type RegionalReportCreateOrConnectWithoutUserInput = {
    where: RegionalReportWhereUniqueInput
    create: XOR<RegionalReportCreateWithoutUserInput, RegionalReportUncheckedCreateWithoutUserInput>
  }

  export type RegionalReportCreateManyUserInputEnvelope = {
    data: RegionalReportCreateManyUserInput | RegionalReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ipAddress?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ipAddress?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutGeneratedByInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    authorizedBy?: UserCreateNestedOneWithoutAuthorizedReportsInput
    region?: RegionCreateNestedOneWithoutGeneratedReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutGeneratedReportsInput
    deliveries?: ReportDeliveryCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutGeneratedByInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    authorizedById?: string | null
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    deliveries?: ReportDeliveryUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutGeneratedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutGeneratedByInput, ReportUncheckedCreateWithoutGeneratedByInput>
  }

  export type ReportCreateManyGeneratedByInputEnvelope = {
    data: ReportCreateManyGeneratedByInput | ReportCreateManyGeneratedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutAuthorizedByInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy: UserCreateNestedOneWithoutReportsInput
    region?: RegionCreateNestedOneWithoutGeneratedReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutGeneratedReportsInput
    deliveries?: ReportDeliveryCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutAuthorizedByInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    deliveries?: ReportDeliveryUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutAuthorizedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAuthorizedByInput, ReportUncheckedCreateWithoutAuthorizedByInput>
  }

  export type ReportCreateManyAuthorizedByInputEnvelope = {
    data: ReportCreateManyAuthorizedByInput | ReportCreateManyAuthorizedByInput[]
    skipDuplicates?: boolean
  }

  export type NewsReadReceiptCreateWithoutUserInput = {
    id?: string
    readAt?: Date | string
    report: RegionalReportCreateNestedOneWithoutReadReceiptsInput
  }

  export type NewsReadReceiptUncheckedCreateWithoutUserInput = {
    id?: string
    reportId: string
    readAt?: Date | string
  }

  export type NewsReadReceiptCreateOrConnectWithoutUserInput = {
    where: NewsReadReceiptWhereUniqueInput
    create: XOR<NewsReadReceiptCreateWithoutUserInput, NewsReadReceiptUncheckedCreateWithoutUserInput>
  }

  export type NewsReadReceiptCreateManyUserInputEnvelope = {
    data: NewsReadReceiptCreateManyUserInput | NewsReadReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutAssignedToInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    vereda?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    region: RegionCreateNestedOneWithoutVisitsInput
    municipality?: MunicipalityCreateNestedOneWithoutVisitsInput
    assignedBy?: UserCreateNestedOneWithoutDelegatedVisitsInput
    logs?: VisitLogCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutAssignedToInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: VisitLogUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutAssignedToInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutAssignedToInput, VisitUncheckedCreateWithoutAssignedToInput>
  }

  export type VisitCreateManyAssignedToInputEnvelope = {
    data: VisitCreateManyAssignedToInput | VisitCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutAssignedByInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    vereda?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    region: RegionCreateNestedOneWithoutVisitsInput
    municipality?: MunicipalityCreateNestedOneWithoutVisitsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedVisitsInput
    logs?: VisitLogCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutAssignedByInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: VisitLogUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutAssignedByInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutAssignedByInput, VisitUncheckedCreateWithoutAssignedByInput>
  }

  export type VisitCreateManyAssignedByInputEnvelope = {
    data: VisitCreateManyAssignedByInput | VisitCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type VisitLogCreateWithoutUserInput = {
    id?: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    visit: VisitCreateNestedOneWithoutLogsInput
  }

  export type VisitLogUncheckedCreateWithoutUserInput = {
    id?: string
    visitId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type VisitLogCreateOrConnectWithoutUserInput = {
    where: VisitLogWhereUniqueInput
    create: XOR<VisitLogCreateWithoutUserInput, VisitLogUncheckedCreateWithoutUserInput>
  }

  export type VisitLogCreateManyUserInputEnvelope = {
    data: VisitLogCreateManyUserInput | VisitLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutUsersInput = {
    update: XOR<RegionUpdateWithoutUsersInput, RegionUncheckedUpdateWithoutUsersInput>
    create: XOR<RegionCreateWithoutUsersInput, RegionUncheckedCreateWithoutUsersInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutUsersInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutUsersInput, RegionUncheckedUpdateWithoutUsersInput>
  }

  export type RegionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type MunicipalityUpsertWithoutUsersInput = {
    update: XOR<MunicipalityUpdateWithoutUsersInput, MunicipalityUncheckedUpdateWithoutUsersInput>
    create: XOR<MunicipalityCreateWithoutUsersInput, MunicipalityUncheckedCreateWithoutUsersInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutUsersInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutUsersInput, MunicipalityUncheckedUpdateWithoutUsersInput>
  }

  export type MunicipalityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type RegionUpsertWithWhereUniqueWithoutAssignedUsersInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutAssignedUsersInput, RegionUncheckedUpdateWithoutAssignedUsersInput>
    create: XOR<RegionCreateWithoutAssignedUsersInput, RegionUncheckedCreateWithoutAssignedUsersInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutAssignedUsersInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutAssignedUsersInput, RegionUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type RegionUpdateManyWithWhereWithoutAssignedUsersInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutAssignedUsersInput>
  }

  export type RegionScalarWhereInput = {
    AND?: RegionScalarWhereInput | RegionScalarWhereInput[]
    OR?: RegionScalarWhereInput[]
    NOT?: RegionScalarWhereInput | RegionScalarWhereInput[]
    id?: StringFilter<"Region"> | string
    name?: StringFilter<"Region"> | string
    code?: StringFilter<"Region"> | string
  }

  export type MunicipalityUpsertWithWhereUniqueWithoutAssignedUsersInput = {
    where: MunicipalityWhereUniqueInput
    update: XOR<MunicipalityUpdateWithoutAssignedUsersInput, MunicipalityUncheckedUpdateWithoutAssignedUsersInput>
    create: XOR<MunicipalityCreateWithoutAssignedUsersInput, MunicipalityUncheckedCreateWithoutAssignedUsersInput>
  }

  export type MunicipalityUpdateWithWhereUniqueWithoutAssignedUsersInput = {
    where: MunicipalityWhereUniqueInput
    data: XOR<MunicipalityUpdateWithoutAssignedUsersInput, MunicipalityUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type MunicipalityUpdateManyWithWhereWithoutAssignedUsersInput = {
    where: MunicipalityScalarWhereInput
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyWithoutAssignedUsersInput>
  }

  export type VeredaUpsertWithWhereUniqueWithoutAssignedUsersInput = {
    where: VeredaWhereUniqueInput
    update: XOR<VeredaUpdateWithoutAssignedUsersInput, VeredaUncheckedUpdateWithoutAssignedUsersInput>
    create: XOR<VeredaCreateWithoutAssignedUsersInput, VeredaUncheckedCreateWithoutAssignedUsersInput>
  }

  export type VeredaUpdateWithWhereUniqueWithoutAssignedUsersInput = {
    where: VeredaWhereUniqueInput
    data: XOR<VeredaUpdateWithoutAssignedUsersInput, VeredaUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type VeredaUpdateManyWithWhereWithoutAssignedUsersInput = {
    where: VeredaScalarWhereInput
    data: XOR<VeredaUpdateManyMutationInput, VeredaUncheckedUpdateManyWithoutAssignedUsersInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DocumentCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentCommentWhereUniqueInput
    update: XOR<DocumentCommentUpdateWithoutUserInput, DocumentCommentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentCommentWhereUniqueInput
    data: XOR<DocumentCommentUpdateWithoutUserInput, DocumentCommentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentCommentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentCommentScalarWhereInput
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentCommentScalarWhereInput = {
    AND?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
    OR?: DocumentCommentScalarWhereInput[]
    NOT?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
    id?: StringFilter<"DocumentComment"> | string
    documentId?: StringFilter<"DocumentComment"> | string
    userId?: StringFilter<"DocumentComment"> | string
    content?: StringFilter<"DocumentComment"> | string
    createdAt?: DateTimeFilter<"DocumentComment"> | Date | string
  }

  export type RegionalReportUpsertWithWhereUniqueWithoutUserInput = {
    where: RegionalReportWhereUniqueInput
    update: XOR<RegionalReportUpdateWithoutUserInput, RegionalReportUncheckedUpdateWithoutUserInput>
    create: XOR<RegionalReportCreateWithoutUserInput, RegionalReportUncheckedCreateWithoutUserInput>
  }

  export type RegionalReportUpdateWithWhereUniqueWithoutUserInput = {
    where: RegionalReportWhereUniqueInput
    data: XOR<RegionalReportUpdateWithoutUserInput, RegionalReportUncheckedUpdateWithoutUserInput>
  }

  export type RegionalReportUpdateManyWithWhereWithoutUserInput = {
    where: RegionalReportScalarWhereInput
    data: XOR<RegionalReportUpdateManyMutationInput, RegionalReportUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutGeneratedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutGeneratedByInput, ReportUncheckedUpdateWithoutGeneratedByInput>
    create: XOR<ReportCreateWithoutGeneratedByInput, ReportUncheckedCreateWithoutGeneratedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutGeneratedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutGeneratedByInput, ReportUncheckedUpdateWithoutGeneratedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutGeneratedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutGeneratedByInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutAuthorizedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutAuthorizedByInput, ReportUncheckedUpdateWithoutAuthorizedByInput>
    create: XOR<ReportCreateWithoutAuthorizedByInput, ReportUncheckedCreateWithoutAuthorizedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutAuthorizedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutAuthorizedByInput, ReportUncheckedUpdateWithoutAuthorizedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutAuthorizedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutAuthorizedByInput>
  }

  export type NewsReadReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: NewsReadReceiptWhereUniqueInput
    update: XOR<NewsReadReceiptUpdateWithoutUserInput, NewsReadReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<NewsReadReceiptCreateWithoutUserInput, NewsReadReceiptUncheckedCreateWithoutUserInput>
  }

  export type NewsReadReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: NewsReadReceiptWhereUniqueInput
    data: XOR<NewsReadReceiptUpdateWithoutUserInput, NewsReadReceiptUncheckedUpdateWithoutUserInput>
  }

  export type NewsReadReceiptUpdateManyWithWhereWithoutUserInput = {
    where: NewsReadReceiptScalarWhereInput
    data: XOR<NewsReadReceiptUpdateManyMutationInput, NewsReadReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type NewsReadReceiptScalarWhereInput = {
    AND?: NewsReadReceiptScalarWhereInput | NewsReadReceiptScalarWhereInput[]
    OR?: NewsReadReceiptScalarWhereInput[]
    NOT?: NewsReadReceiptScalarWhereInput | NewsReadReceiptScalarWhereInput[]
    id?: StringFilter<"NewsReadReceipt"> | string
    userId?: StringFilter<"NewsReadReceipt"> | string
    reportId?: StringFilter<"NewsReadReceipt"> | string
    readAt?: DateTimeFilter<"NewsReadReceipt"> | Date | string
  }

  export type VisitUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutAssignedToInput, VisitUncheckedUpdateWithoutAssignedToInput>
    create: XOR<VisitCreateWithoutAssignedToInput, VisitUncheckedCreateWithoutAssignedToInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutAssignedToInput, VisitUncheckedUpdateWithoutAssignedToInput>
  }

  export type VisitUpdateManyWithWhereWithoutAssignedToInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type VisitUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutAssignedByInput, VisitUncheckedUpdateWithoutAssignedByInput>
    create: XOR<VisitCreateWithoutAssignedByInput, VisitUncheckedCreateWithoutAssignedByInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutAssignedByInput, VisitUncheckedUpdateWithoutAssignedByInput>
  }

  export type VisitUpdateManyWithWhereWithoutAssignedByInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type VisitLogUpsertWithWhereUniqueWithoutUserInput = {
    where: VisitLogWhereUniqueInput
    update: XOR<VisitLogUpdateWithoutUserInput, VisitLogUncheckedUpdateWithoutUserInput>
    create: XOR<VisitLogCreateWithoutUserInput, VisitLogUncheckedCreateWithoutUserInput>
  }

  export type VisitLogUpdateWithWhereUniqueWithoutUserInput = {
    where: VisitLogWhereUniqueInput
    data: XOR<VisitLogUpdateWithoutUserInput, VisitLogUncheckedUpdateWithoutUserInput>
  }

  export type VisitLogUpdateManyWithWhereWithoutUserInput = {
    where: VisitLogScalarWhereInput
    data: XOR<VisitLogUpdateManyMutationInput, VisitLogUncheckedUpdateManyWithoutUserInput>
  }

  export type VisitLogScalarWhereInput = {
    AND?: VisitLogScalarWhereInput | VisitLogScalarWhereInput[]
    OR?: VisitLogScalarWhereInput[]
    NOT?: VisitLogScalarWhereInput | VisitLogScalarWhereInput[]
    id?: StringFilter<"VisitLog"> | string
    visitId?: StringFilter<"VisitLog"> | string
    userId?: StringFilter<"VisitLog"> | string
    action?: StringFilter<"VisitLog"> | string
    metadata?: JsonNullableFilter<"VisitLog">
    timestamp?: DateTimeFilter<"VisitLog"> | Date | string
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type RegionCreateWithoutDocumentsInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutDocumentsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutDocumentsInput, RegionUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentCommentCreateWithoutDocumentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type DocumentCommentUncheckedCreateWithoutDocumentInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type DocumentCommentCreateOrConnectWithoutDocumentInput = {
    where: DocumentCommentWhereUniqueInput
    create: XOR<DocumentCommentCreateWithoutDocumentInput, DocumentCommentUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentCommentCreateManyDocumentInputEnvelope = {
    data: DocumentCommentCreateManyDocumentInput | DocumentCommentCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RegionUpsertWithoutDocumentsInput = {
    update: XOR<RegionUpdateWithoutDocumentsInput, RegionUncheckedUpdateWithoutDocumentsInput>
    create: XOR<RegionCreateWithoutDocumentsInput, RegionUncheckedCreateWithoutDocumentsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutDocumentsInput, RegionUncheckedUpdateWithoutDocumentsInput>
  }

  export type RegionUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentCommentWhereUniqueInput
    update: XOR<DocumentCommentUpdateWithoutDocumentInput, DocumentCommentUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentCommentCreateWithoutDocumentInput, DocumentCommentUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentCommentWhereUniqueInput
    data: XOR<DocumentCommentUpdateWithoutDocumentInput, DocumentCommentUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentCommentUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentCommentScalarWhereInput
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutCommentsInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutDocumentsInput
    region?: RegionCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    uploaderId: string
    regionId?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutCommentsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCommentsInput, DocumentUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type DocumentUpsertWithoutCommentsInput = {
    update: XOR<DocumentUpdateWithoutCommentsInput, DocumentUncheckedUpdateWithoutCommentsInput>
    create: XOR<DocumentCreateWithoutCommentsInput, DocumentUncheckedCreateWithoutCommentsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutCommentsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutCommentsInput, DocumentUncheckedUpdateWithoutCommentsInput>
  }

  export type DocumentUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    region?: RegionUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNewsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNewsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNewsInput, UserUncheckedCreateWithoutNewsInput>
  }

  export type RegionCreateWithoutReportsInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutReportsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutReportsInput, RegionUncheckedCreateWithoutReportsInput>
  }

  export type MunicipalityCreateWithoutReportsInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    users?: UserCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    regionId: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutReportsInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutReportsInput, MunicipalityUncheckedCreateWithoutReportsInput>
  }

  export type AlertCreateWithoutReportInput = {
    id?: string
    priority: $Enums.Priority
    status?: string
    createdAt?: Date | string
  }

  export type AlertUncheckedCreateWithoutReportInput = {
    id?: string
    priority: $Enums.Priority
    status?: string
    createdAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutReportInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutReportInput, AlertUncheckedCreateWithoutReportInput>
  }

  export type AlertCreateManyReportInputEnvelope = {
    data: AlertCreateManyReportInput | AlertCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type NewsReadReceiptCreateWithoutReportInput = {
    id?: string
    readAt?: Date | string
    user: UserCreateNestedOneWithoutReadReceiptsInput
  }

  export type NewsReadReceiptUncheckedCreateWithoutReportInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type NewsReadReceiptCreateOrConnectWithoutReportInput = {
    where: NewsReadReceiptWhereUniqueInput
    create: XOR<NewsReadReceiptCreateWithoutReportInput, NewsReadReceiptUncheckedCreateWithoutReportInput>
  }

  export type NewsReadReceiptCreateManyReportInputEnvelope = {
    data: NewsReadReceiptCreateManyReportInput | NewsReadReceiptCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNewsInput = {
    update: XOR<UserUpdateWithoutNewsInput, UserUncheckedUpdateWithoutNewsInput>
    create: XOR<UserCreateWithoutNewsInput, UserUncheckedCreateWithoutNewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNewsInput, UserUncheckedUpdateWithoutNewsInput>
  }

  export type UserUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RegionUpsertWithoutReportsInput = {
    update: XOR<RegionUpdateWithoutReportsInput, RegionUncheckedUpdateWithoutReportsInput>
    create: XOR<RegionCreateWithoutReportsInput, RegionUncheckedCreateWithoutReportsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutReportsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutReportsInput, RegionUncheckedUpdateWithoutReportsInput>
  }

  export type RegionUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type MunicipalityUpsertWithoutReportsInput = {
    update: XOR<MunicipalityUpdateWithoutReportsInput, MunicipalityUncheckedUpdateWithoutReportsInput>
    create: XOR<MunicipalityCreateWithoutReportsInput, MunicipalityUncheckedCreateWithoutReportsInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutReportsInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutReportsInput, MunicipalityUncheckedUpdateWithoutReportsInput>
  }

  export type MunicipalityUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutReportInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutReportInput, AlertUncheckedUpdateWithoutReportInput>
    create: XOR<AlertCreateWithoutReportInput, AlertUncheckedCreateWithoutReportInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutReportInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutReportInput, AlertUncheckedUpdateWithoutReportInput>
  }

  export type AlertUpdateManyWithWhereWithoutReportInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutReportInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    reportId?: StringFilter<"Alert"> | string
    priority?: EnumPriorityFilter<"Alert"> | $Enums.Priority
    status?: StringFilter<"Alert"> | string
    createdAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type NewsReadReceiptUpsertWithWhereUniqueWithoutReportInput = {
    where: NewsReadReceiptWhereUniqueInput
    update: XOR<NewsReadReceiptUpdateWithoutReportInput, NewsReadReceiptUncheckedUpdateWithoutReportInput>
    create: XOR<NewsReadReceiptCreateWithoutReportInput, NewsReadReceiptUncheckedCreateWithoutReportInput>
  }

  export type NewsReadReceiptUpdateWithWhereUniqueWithoutReportInput = {
    where: NewsReadReceiptWhereUniqueInput
    data: XOR<NewsReadReceiptUpdateWithoutReportInput, NewsReadReceiptUncheckedUpdateWithoutReportInput>
  }

  export type NewsReadReceiptUpdateManyWithWhereWithoutReportInput = {
    where: NewsReadReceiptScalarWhereInput
    data: XOR<NewsReadReceiptUpdateManyMutationInput, NewsReadReceiptUncheckedUpdateManyWithoutReportInput>
  }

  export type RegionalReportCreateWithoutAlertsInput = {
    id?: string
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNewsInput
    region?: RegionCreateNestedOneWithoutReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutReportsInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUncheckedCreateWithoutAlertsInput = {
    id?: string
    userId: string
    regionId?: string | null
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutReportInput
  }

  export type RegionalReportCreateOrConnectWithoutAlertsInput = {
    where: RegionalReportWhereUniqueInput
    create: XOR<RegionalReportCreateWithoutAlertsInput, RegionalReportUncheckedCreateWithoutAlertsInput>
  }

  export type RegionalReportUpsertWithoutAlertsInput = {
    update: XOR<RegionalReportUpdateWithoutAlertsInput, RegionalReportUncheckedUpdateWithoutAlertsInput>
    create: XOR<RegionalReportCreateWithoutAlertsInput, RegionalReportUncheckedCreateWithoutAlertsInput>
    where?: RegionalReportWhereInput
  }

  export type RegionalReportUpdateToOneWithWhereWithoutAlertsInput = {
    where?: RegionalReportWhereInput
    data: XOR<RegionalReportUpdateWithoutAlertsInput, RegionalReportUncheckedUpdateWithoutAlertsInput>
  }

  export type RegionalReportUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNewsNestedInput
    region?: RegionUpdateOneWithoutReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutReportsNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutReportNestedInput
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutAuthorizedReportsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthorizedReportsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthorizedReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorizedReportsInput, UserUncheckedCreateWithoutAuthorizedReportsInput>
  }

  export type RegionCreateWithoutGeneratedReportsInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    visits?: VisitCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutGeneratedReportsInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    visits?: VisitUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutGeneratedReportsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutGeneratedReportsInput, RegionUncheckedCreateWithoutGeneratedReportsInput>
  }

  export type MunicipalityCreateWithoutGeneratedReportsInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    users?: UserCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    visits?: VisitCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutGeneratedReportsInput = {
    id?: string
    name: string
    regionId: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    visits?: VisitUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutGeneratedReportsInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutGeneratedReportsInput, MunicipalityUncheckedCreateWithoutGeneratedReportsInput>
  }

  export type ReportDeliveryCreateWithoutReportInput = {
    id?: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt?: Date | string
  }

  export type ReportDeliveryUncheckedCreateWithoutReportInput = {
    id?: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt?: Date | string
  }

  export type ReportDeliveryCreateOrConnectWithoutReportInput = {
    where: ReportDeliveryWhereUniqueInput
    create: XOR<ReportDeliveryCreateWithoutReportInput, ReportDeliveryUncheckedCreateWithoutReportInput>
  }

  export type ReportDeliveryCreateManyReportInputEnvelope = {
    data: ReportDeliveryCreateManyReportInput | ReportDeliveryCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAuthorizedReportsInput = {
    update: XOR<UserUpdateWithoutAuthorizedReportsInput, UserUncheckedUpdateWithoutAuthorizedReportsInput>
    create: XOR<UserCreateWithoutAuthorizedReportsInput, UserUncheckedCreateWithoutAuthorizedReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorizedReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorizedReportsInput, UserUncheckedUpdateWithoutAuthorizedReportsInput>
  }

  export type UserUpdateWithoutAuthorizedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorizedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RegionUpsertWithoutGeneratedReportsInput = {
    update: XOR<RegionUpdateWithoutGeneratedReportsInput, RegionUncheckedUpdateWithoutGeneratedReportsInput>
    create: XOR<RegionCreateWithoutGeneratedReportsInput, RegionUncheckedCreateWithoutGeneratedReportsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutGeneratedReportsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutGeneratedReportsInput, RegionUncheckedUpdateWithoutGeneratedReportsInput>
  }

  export type RegionUpdateWithoutGeneratedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutGeneratedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type MunicipalityUpsertWithoutGeneratedReportsInput = {
    update: XOR<MunicipalityUpdateWithoutGeneratedReportsInput, MunicipalityUncheckedUpdateWithoutGeneratedReportsInput>
    create: XOR<MunicipalityCreateWithoutGeneratedReportsInput, MunicipalityUncheckedCreateWithoutGeneratedReportsInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutGeneratedReportsInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutGeneratedReportsInput, MunicipalityUncheckedUpdateWithoutGeneratedReportsInput>
  }

  export type MunicipalityUpdateWithoutGeneratedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutGeneratedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type ReportDeliveryUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportDeliveryWhereUniqueInput
    update: XOR<ReportDeliveryUpdateWithoutReportInput, ReportDeliveryUncheckedUpdateWithoutReportInput>
    create: XOR<ReportDeliveryCreateWithoutReportInput, ReportDeliveryUncheckedCreateWithoutReportInput>
  }

  export type ReportDeliveryUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportDeliveryWhereUniqueInput
    data: XOR<ReportDeliveryUpdateWithoutReportInput, ReportDeliveryUncheckedUpdateWithoutReportInput>
  }

  export type ReportDeliveryUpdateManyWithWhereWithoutReportInput = {
    where: ReportDeliveryScalarWhereInput
    data: XOR<ReportDeliveryUpdateManyMutationInput, ReportDeliveryUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportDeliveryScalarWhereInput = {
    AND?: ReportDeliveryScalarWhereInput | ReportDeliveryScalarWhereInput[]
    OR?: ReportDeliveryScalarWhereInput[]
    NOT?: ReportDeliveryScalarWhereInput | ReportDeliveryScalarWhereInput[]
    id?: StringFilter<"ReportDelivery"> | string
    reportId?: StringFilter<"ReportDelivery"> | string
    recipient?: StringFilter<"ReportDelivery"> | string
    channel?: EnumDeliveryChannelFilter<"ReportDelivery"> | $Enums.DeliveryChannel
    status?: StringFilter<"ReportDelivery"> | string
    sentAt?: DateTimeFilter<"ReportDelivery"> | Date | string
  }

  export type ReportCreateWithoutDeliveriesInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy: UserCreateNestedOneWithoutReportsInput
    authorizedBy?: UserCreateNestedOneWithoutAuthorizedReportsInput
    region?: RegionCreateNestedOneWithoutGeneratedReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutGeneratedReportsInput
  }

  export type ReportUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutDeliveriesInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutDeliveriesInput, ReportUncheckedCreateWithoutDeliveriesInput>
  }

  export type ReportUpsertWithoutDeliveriesInput = {
    update: XOR<ReportUpdateWithoutDeliveriesInput, ReportUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<ReportCreateWithoutDeliveriesInput, ReportUncheckedCreateWithoutDeliveriesInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutDeliveriesInput, ReportUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ReportUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    authorizedBy?: UserUpdateOneWithoutAuthorizedReportsNestedInput
    region?: RegionUpdateOneWithoutGeneratedReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutGeneratedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReadReceiptsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReadReceiptsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReadReceiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReadReceiptsInput, UserUncheckedCreateWithoutReadReceiptsInput>
  }

  export type RegionalReportCreateWithoutReadReceiptsInput = {
    id?: string
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNewsInput
    region?: RegionCreateNestedOneWithoutReportsInput
    municipality?: MunicipalityCreateNestedOneWithoutReportsInput
    alerts?: AlertCreateNestedManyWithoutReportInput
  }

  export type RegionalReportUncheckedCreateWithoutReadReceiptsInput = {
    id?: string
    userId: string
    regionId?: string | null
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutReportInput
  }

  export type RegionalReportCreateOrConnectWithoutReadReceiptsInput = {
    where: RegionalReportWhereUniqueInput
    create: XOR<RegionalReportCreateWithoutReadReceiptsInput, RegionalReportUncheckedCreateWithoutReadReceiptsInput>
  }

  export type UserUpsertWithoutReadReceiptsInput = {
    update: XOR<UserUpdateWithoutReadReceiptsInput, UserUncheckedUpdateWithoutReadReceiptsInput>
    create: XOR<UserCreateWithoutReadReceiptsInput, UserUncheckedCreateWithoutReadReceiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReadReceiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReadReceiptsInput, UserUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type UserUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RegionalReportUpsertWithoutReadReceiptsInput = {
    update: XOR<RegionalReportUpdateWithoutReadReceiptsInput, RegionalReportUncheckedUpdateWithoutReadReceiptsInput>
    create: XOR<RegionalReportCreateWithoutReadReceiptsInput, RegionalReportUncheckedCreateWithoutReadReceiptsInput>
    where?: RegionalReportWhereInput
  }

  export type RegionalReportUpdateToOneWithWhereWithoutReadReceiptsInput = {
    where?: RegionalReportWhereInput
    data: XOR<RegionalReportUpdateWithoutReadReceiptsInput, RegionalReportUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type RegionalReportUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNewsNestedInput
    region?: RegionUpdateOneWithoutReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutReportsNestedInput
    alerts?: AlertUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutReportNestedInput
  }

  export type RegionCreateWithoutVisitsInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutRegionInput
    reports?: RegionalReportCreateNestedManyWithoutRegionInput
    generatedReports?: ReportCreateNestedManyWithoutRegionInput
    documents?: DocumentCreateNestedManyWithoutRegionInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutVisitsInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutRegionInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutRegionInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutRegionInput
    documents?: DocumentUncheckedCreateNestedManyWithoutRegionInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedRegionsInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutVisitsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutVisitsInput, RegionUncheckedCreateWithoutVisitsInput>
  }

  export type MunicipalityCreateWithoutVisitsInput = {
    id?: string
    name: string
    region: RegionCreateNestedOneWithoutMunicipalitiesInput
    users?: UserCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutVisitsInput = {
    id?: string
    name: string
    regionId: string
    users?: UserUncheckedCreateNestedManyWithoutMunicipalityInput
    assignedUsers?: UserUncheckedCreateNestedManyWithoutAssignedMunicipalitiesInput
    reports?: RegionalReportUncheckedCreateNestedManyWithoutMunicipalityInput
    generatedReports?: ReportUncheckedCreateNestedManyWithoutMunicipalityInput
    veredas?: VeredaUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutVisitsInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutVisitsInput, MunicipalityUncheckedCreateWithoutVisitsInput>
  }

  export type UserCreateWithoutAssignedVisitsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedVisitsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedVisitsInput, UserUncheckedCreateWithoutAssignedVisitsInput>
  }

  export type UserCreateWithoutDelegatedVisitsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    visitLogs?: VisitLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDelegatedVisitsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    visitLogs?: VisitLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDelegatedVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDelegatedVisitsInput, UserUncheckedCreateWithoutDelegatedVisitsInput>
  }

  export type VisitLogCreateWithoutVisitInput = {
    id?: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutVisitLogsInput
  }

  export type VisitLogUncheckedCreateWithoutVisitInput = {
    id?: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type VisitLogCreateOrConnectWithoutVisitInput = {
    where: VisitLogWhereUniqueInput
    create: XOR<VisitLogCreateWithoutVisitInput, VisitLogUncheckedCreateWithoutVisitInput>
  }

  export type VisitLogCreateManyVisitInputEnvelope = {
    data: VisitLogCreateManyVisitInput | VisitLogCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutVisitsInput = {
    update: XOR<RegionUpdateWithoutVisitsInput, RegionUncheckedUpdateWithoutVisitsInput>
    create: XOR<RegionCreateWithoutVisitsInput, RegionUncheckedCreateWithoutVisitsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutVisitsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutVisitsInput, RegionUncheckedUpdateWithoutVisitsInput>
  }

  export type RegionUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedRegionsNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type MunicipalityUpsertWithoutVisitsInput = {
    update: XOR<MunicipalityUpdateWithoutVisitsInput, MunicipalityUncheckedUpdateWithoutVisitsInput>
    create: XOR<MunicipalityCreateWithoutVisitsInput, MunicipalityUncheckedCreateWithoutVisitsInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutVisitsInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutVisitsInput, MunicipalityUncheckedUpdateWithoutVisitsInput>
  }

  export type MunicipalityUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type UserUpsertWithoutAssignedVisitsInput = {
    update: XOR<UserUpdateWithoutAssignedVisitsInput, UserUncheckedUpdateWithoutAssignedVisitsInput>
    create: XOR<UserCreateWithoutAssignedVisitsInput, UserUncheckedCreateWithoutAssignedVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedVisitsInput, UserUncheckedUpdateWithoutAssignedVisitsInput>
  }

  export type UserUpdateWithoutAssignedVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDelegatedVisitsInput = {
    update: XOR<UserUpdateWithoutDelegatedVisitsInput, UserUncheckedUpdateWithoutDelegatedVisitsInput>
    create: XOR<UserCreateWithoutDelegatedVisitsInput, UserUncheckedCreateWithoutDelegatedVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDelegatedVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDelegatedVisitsInput, UserUncheckedUpdateWithoutDelegatedVisitsInput>
  }

  export type UserUpdateWithoutDelegatedVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDelegatedVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VisitLogUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitLogWhereUniqueInput
    update: XOR<VisitLogUpdateWithoutVisitInput, VisitLogUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitLogCreateWithoutVisitInput, VisitLogUncheckedCreateWithoutVisitInput>
  }

  export type VisitLogUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitLogWhereUniqueInput
    data: XOR<VisitLogUpdateWithoutVisitInput, VisitLogUncheckedUpdateWithoutVisitInput>
  }

  export type VisitLogUpdateManyWithWhereWithoutVisitInput = {
    where: VisitLogScalarWhereInput
    data: XOR<VisitLogUpdateManyMutationInput, VisitLogUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitCreateWithoutLogsInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    vereda?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    region: RegionCreateNestedOneWithoutVisitsInput
    municipality?: MunicipalityCreateNestedOneWithoutVisitsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedVisitsInput
    assignedBy?: UserCreateNestedOneWithoutDelegatedVisitsInput
  }

  export type VisitUncheckedCreateWithoutLogsInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCreateOrConnectWithoutLogsInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutLogsInput, VisitUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutVisitLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    region?: RegionCreateNestedOneWithoutUsersInput
    municipality?: MunicipalityCreateNestedOneWithoutUsersInput
    assignedRegions?: RegionCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentCreateNestedManyWithoutUserInput
    news?: RegionalReportCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptCreateNestedManyWithoutUserInput
    assignedVisits?: VisitCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutVisitLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
    assignedRegions?: RegionUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedMunicipalities?: MunicipalityUncheckedCreateNestedManyWithoutAssignedUsersInput
    assignedVeredas?: VeredaUncheckedCreateNestedManyWithoutAssignedUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    news?: RegionalReportUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratedByInput
    authorizedReports?: ReportUncheckedCreateNestedManyWithoutAuthorizedByInput
    readReceipts?: NewsReadReceiptUncheckedCreateNestedManyWithoutUserInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedToInput
    delegatedVisits?: VisitUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutVisitLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisitLogsInput, UserUncheckedCreateWithoutVisitLogsInput>
  }

  export type VisitUpsertWithoutLogsInput = {
    update: XOR<VisitUpdateWithoutLogsInput, VisitUncheckedUpdateWithoutLogsInput>
    create: XOR<VisitCreateWithoutLogsInput, VisitUncheckedCreateWithoutLogsInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutLogsInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutLogsInput, VisitUncheckedUpdateWithoutLogsInput>
  }

  export type VisitUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutVisitsNestedInput
    municipality?: MunicipalityUpdateOneWithoutVisitsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedVisitsNestedInput
    assignedBy?: UserUpdateOneWithoutDelegatedVisitsNestedInput
  }

  export type VisitUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutVisitLogsInput = {
    update: XOR<UserUpdateWithoutVisitLogsInput, UserUncheckedUpdateWithoutVisitLogsInput>
    create: XOR<UserCreateWithoutVisitLogsInput, UserUncheckedCreateWithoutVisitLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVisitLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVisitLogsInput, UserUncheckedUpdateWithoutVisitLogsInput>
  }

  export type UserUpdateWithoutVisitLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVisitLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateManyRegionInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    municipalityId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
  }

  export type RegionalReportCreateManyRegionInput = {
    id?: string
    userId: string
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
  }

  export type ReportCreateManyRegionInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type VisitCreateManyRegionInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyRegionInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    uploaderId: string
    createdAt?: Date | string
  }

  export type MunicipalityCreateManyRegionInput = {
    id?: string
    name: string
  }

  export type UserUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RegionalReportUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNewsNestedInput
    municipality?: MunicipalityUpdateOneWithoutReportsNestedInput
    alerts?: AlertUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    authorizedBy?: UserUpdateOneWithoutAuthorizedReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutGeneratedReportsNestedInput
    deliveries?: ReportDeliveryUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: ReportDeliveryUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipality?: MunicipalityUpdateOneWithoutVisitsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedVisitsNestedInput
    assignedBy?: UserUpdateOneWithoutDelegatedVisitsNestedInput
    logs?: VisitLogUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: VisitLogUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutAssignedRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MunicipalityUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedMunicipalitiesNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyMunicipalityInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    dni: string
    phone?: string | null
    role?: $Enums.Role
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: string | null
    createdAt?: Date | string
    lastLogin?: Date | string | null
    acceptedTerms?: boolean
    acceptedAt?: Date | string | null
  }

  export type RegionalReportCreateManyMunicipalityInput = {
    id?: string
    userId: string
    regionId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
  }

  export type ReportCreateManyMunicipalityInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    authorizedById?: string | null
    regionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type VisitCreateManyMunicipalityInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    vereda?: string | null
    assignedToId?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VeredaCreateManyMunicipalityInput = {
    id?: string
    name: string
  }

  export type UserUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutAssignedMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedVeredas?: VeredaUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RegionalReportUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNewsNestedInput
    region?: RegionUpdateOneWithoutReportsNestedInput
    alerts?: AlertUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    authorizedBy?: UserUpdateOneWithoutAuthorizedReportsNestedInput
    region?: RegionUpdateOneWithoutGeneratedReportsNestedInput
    deliveries?: ReportDeliveryUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: ReportDeliveryUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutVisitsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedVisitsNestedInput
    assignedBy?: UserUpdateOneWithoutDelegatedVisitsNestedInput
    logs?: VisitLogUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: VisitLogUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VeredaUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    assignedUsers?: UserUpdateManyWithoutAssignedVeredasNestedInput
  }

  export type VeredaUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    assignedUsers?: UserUncheckedUpdateManyWithoutAssignedVeredasNestedInput
  }

  export type VeredaUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutAssignedVeredasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneWithoutUsersNestedInput
    municipality?: MunicipalityUpdateOneWithoutUsersNestedInput
    assignedRegions?: RegionUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUpdateManyWithoutUserNestedInput
    news?: RegionalReportUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedVeredasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedRegions?: RegionUncheckedUpdateManyWithoutAssignedUsersNestedInput
    assignedMunicipalities?: MunicipalityUncheckedUpdateManyWithoutAssignedUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    news?: RegionalReportUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratedByNestedInput
    authorizedReports?: ReportUncheckedUpdateManyWithoutAuthorizedByNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutAssignedToNestedInput
    delegatedVisits?: VisitUncheckedUpdateManyWithoutAssignedByNestedInput
    visitLogs?: VisitLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedVeredasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentCreateManyUploaderInput = {
    id?: string
    title: string
    url: string
    version?: number
    hash?: string | null
    regionId?: string | null
    createdAt?: Date | string
  }

  export type DocumentCommentCreateManyUserInput = {
    id?: string
    documentId: string
    content: string
    createdAt?: Date | string
  }

  export type RegionalReportCreateManyUserInput = {
    id?: string
    regionId?: string | null
    municipalityId?: string | null
    category: $Enums.NewsCategory
    priority: $Enums.Priority
    title: string
    content: string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ipAddress?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ReportCreateManyGeneratedByInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    authorizedById?: string | null
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type ReportCreateManyAuthorizedByInput = {
    id?: string
    code: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    url: string
    hashSha256: string
    generatedById: string
    regionId?: string | null
    municipalityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type NewsReadReceiptCreateManyUserInput = {
    id?: string
    reportId: string
    readAt?: Date | string
  }

  export type VisitCreateManyAssignedToInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedById?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCreateManyAssignedByInput = {
    id?: string
    source?: $Enums.VisitSource
    reliability?: $Enums.VisitReliability
    citizenId?: string | null
    fullName?: string | null
    addressText: string
    phone?: string | null
    latitude?: number | null
    longitude?: number | null
    gpsAccuracy?: number | null
    verifiedAt?: Date | string | null
    status?: $Enums.VisitStatus
    priority?: $Enums.Priority
    regionId: string
    municipalityId?: string | null
    vereda?: string | null
    assignedToId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitLogCreateManyUserInput = {
    id?: string
    visitId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type RegionUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUpdateManyWithoutRegionNestedInput
    visits?: VisitUpdateManyWithoutRegionNestedInput
    documents?: DocumentUpdateManyWithoutRegionNestedInput
    municipalities?: MunicipalityUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRegionNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutRegionNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutRegionNestedInput
    visits?: VisitUncheckedUpdateManyWithoutRegionNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutRegionNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutMunicipalitiesNestedInput
    users?: UserUpdateManyWithoutMunicipalityNestedInput
    reports?: RegionalReportUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMunicipalityNestedInput
    reports?: RegionalReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    generatedReports?: ReportUncheckedUpdateManyWithoutMunicipalityNestedInput
    visits?: VisitUncheckedUpdateManyWithoutMunicipalityNestedInput
    veredas?: VeredaUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateManyWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    regionId?: StringFieldUpdateOperationsInput | string
  }

  export type VeredaUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipality?: MunicipalityUpdateOneRequiredWithoutVeredasNestedInput
  }

  export type VeredaUncheckedUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: StringFieldUpdateOperationsInput | string
  }

  export type VeredaUncheckedUpdateManyWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneWithoutDocumentsNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type DocumentCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionalReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneWithoutReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutReportsNestedInput
    alerts?: AlertUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutReportNestedInput
    readReceipts?: NewsReadReceiptUncheckedUpdateManyWithoutReportNestedInput
  }

  export type RegionalReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNewsCategoryFieldUpdateOperationsInput | $Enums.NewsCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizedBy?: UserUpdateOneWithoutAuthorizedReportsNestedInput
    region?: RegionUpdateOneWithoutGeneratedReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutGeneratedReportsNestedInput
    deliveries?: ReportDeliveryUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: ReportDeliveryUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutGeneratedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    authorizedById?: NullableStringFieldUpdateOperationsInput | string | null
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutAuthorizedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    region?: RegionUpdateOneWithoutGeneratedReportsNestedInput
    municipality?: MunicipalityUpdateOneWithoutGeneratedReportsNestedInput
    deliveries?: ReportDeliveryUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutAuthorizedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: ReportDeliveryUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutAuthorizedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    url?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    generatedById?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: RegionalReportUpdateOneRequiredWithoutReadReceiptsNestedInput
  }

  export type NewsReadReceiptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutVisitsNestedInput
    municipality?: MunicipalityUpdateOneWithoutVisitsNestedInput
    assignedBy?: UserUpdateOneWithoutDelegatedVisitsNestedInput
    logs?: VisitLogUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: VisitLogUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutVisitsNestedInput
    municipality?: MunicipalityUpdateOneWithoutVisitsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedVisitsNestedInput
    logs?: VisitLogUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: VisitLogUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumVisitSourceFieldUpdateOperationsInput | $Enums.VisitSource
    reliability?: EnumVisitReliabilityFieldUpdateOperationsInput | $Enums.VisitReliability
    citizenId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    addressText?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    regionId?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableStringFieldUpdateOperationsInput | string | null
    vereda?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutLogsNestedInput
  }

  export type VisitLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentCreateManyDocumentInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type DocumentCommentUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type DocumentCommentUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyReportInput = {
    id?: string
    priority: $Enums.Priority
    status?: string
    createdAt?: Date | string
  }

  export type NewsReadReceiptCreateManyReportInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type AlertUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadReceiptsNestedInput
  }

  export type NewsReadReceiptUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsReadReceiptUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDeliveryCreateManyReportInput = {
    id?: string
    recipient: string
    channel: $Enums.DeliveryChannel
    status: string
    sentAt?: Date | string
  }

  export type ReportDeliveryUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDeliveryUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDeliveryUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: EnumDeliveryChannelFieldUpdateOperationsInput | $Enums.DeliveryChannel
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogCreateManyVisitInput = {
    id?: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type VisitLogUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVisitLogsNestedInput
  }

  export type VisitLogUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitLogUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RegionCountOutputTypeDefaultArgs instead
     */
    export type RegionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipalityCountOutputTypeDefaultArgs instead
     */
    export type MunicipalityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VeredaCountOutputTypeDefaultArgs instead
     */
    export type VeredaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VeredaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCountOutputTypeDefaultArgs instead
     */
    export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionalReportCountOutputTypeDefaultArgs instead
     */
    export type RegionalReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionalReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCountOutputTypeDefaultArgs instead
     */
    export type ReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitCountOutputTypeDefaultArgs instead
     */
    export type VisitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionDefaultArgs instead
     */
    export type RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipalityDefaultArgs instead
     */
    export type MunicipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipalityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VeredaDefaultArgs instead
     */
    export type VeredaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VeredaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCommentDefaultArgs instead
     */
    export type DocumentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionalReportDefaultArgs instead
     */
    export type RegionalReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionalReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDeliveryDefaultArgs instead
     */
    export type ReportDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsReadReceiptDefaultArgs instead
     */
    export type NewsReadReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsReadReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitDefaultArgs instead
     */
    export type VisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitLogDefaultArgs instead
     */
    export type VisitLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}